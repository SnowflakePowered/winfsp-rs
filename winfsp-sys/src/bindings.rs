/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const FSP_FSCTL_PRODUCT_NAME: &[u8; 7usize] = b"WinFsp\0";
pub const FSP_FSCTL_PRODUCT_FILE_NAME: &[u8; 7usize] = b"winfsp\0";
pub const FSP_FSCTL_DRIVER_NAME: &[u8; 7usize] = b"WinFsp\0";
pub const FSP_FSCTL_DISK_DEVICE_NAME: &[u8; 12usize] = b"WinFsp.Disk\0";
pub const FSP_FSCTL_NET_DEVICE_NAME: &[u8; 11usize] = b"WinFsp.Net\0";
pub const FSP_FSCTL_MUP_DEVICE_NAME: &[u8; 11usize] = b"WinFsp.Mup\0";
pub const FSP_FSCTL_PRODUCT_REGKEY: &[u8; 16usize] = b"Software\\WinFsp\0";
pub const FSP_FSCTL_PRODUCT_REGKEY_WOW64: u32 = 512;
pub const FSP_FSCTL_PRODUCT_FULL_REGKEY: &[u8; 28usize] = b"Software\\WOW6432Node\\WinFsp\0";
pub const FSP_FSCTL_PRODUCT_FILE_ARCH: &[u8; 4usize] = b"x64\0";
pub const FSP_FSCTL_DEFAULT_ALIGNMENT: u32 = 8;
pub const FSP_FSCTL_VOLUME_PARAMS_PREFIX: &[u8; 15usize] = b"\\VolumeParams=\0";
pub const FSP_FSCTL_TRANSACT_REQ_SIZEMAX: u32 = 16320;
pub const FSP_FSCTL_TRANSACT_RSP_SIZEMAX: u32 = 16384;
pub const FSP_FSCTL_TRANSACT_BATCH_BUFFER_SIZEMIN: u32 = 65536;
pub const FSP_FSCTL_TRANSACT_BUFFER_SIZEMIN: u32 = 16320;
pub const FSP_FSCTL_DEVICECONTROL_SIZEMAX: u32 = 4096;
pub const FSP_DLLNAME: &[u8; 15usize] = b"winfsp-x64.dll\0";
pub const FSP_DLLPATH: &[u8; 19usize] = b"bin\\winfsp-x64.dll\0";
pub const FSP_LAUNCH_REGKEY: &[u8; 25usize] = b"Software\\WinFsp\\Services\0";
pub const FSP_LAUNCH_REGKEY_WOW64: u32 = 512;
pub const FSP_LAUNCH_FULL_REGKEY: &[u8; 37usize] = b"Software\\WOW6432Node\\WinFsp\\Services\0";
pub const FSP_LAUNCH_PIPE_NAME: &[u8; 55usize] =
    b"\\\\.\\pipe\\WinFsp.{14E7137D-22B4-437A-B0C1-D21D1BDF3767}\0";
pub const FSP_LAUNCH_PIPE_BUFFER_SIZE: u32 = 4096;
pub const FSP_LAUNCH_PIPE_SDDL: &[u8; 52usize] =
    b"O:SYG:SYD:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GRDCCR;;;WD)\0";
pub const FSP_LAUNCH_SERVICE_DEFAULT_SDDL: &[u8; 36usize] =
    b"D:P(A;;RPWPLC;;;SY)(A;;RPWPLC;;;BA)\0";
pub const FSP_LAUNCH_SERVICE_WORLD_SDDL: &[u8; 20usize] = b"D:P(A;;RPWPLC;;;WD)\0";
pub type va_list = *mut ::std::os::raw::c_char;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type PHANDLE = *mut HANDLE;
pub type BOOLEAN = BYTE;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    const UNINIT: ::std::mem::MaybeUninit<_LIST_ENTRY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
impl Default for _LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LIST_ENTRY = _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    const UNINIT: ::std::mem::MaybeUninit<_GUID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
pub type GUID = _GUID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    const UNINIT: ::std::mem::MaybeUninit<_GENERIC_MAPPING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::std::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericRead) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericWrite) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericExecute) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GenericAll) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
        )
    );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
pub type SECURITY_INFORMATION = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    pub Type: WORD,
    pub CreatorBackTraceIndex: WORD,
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    pub ProcessLocksList: LIST_ENTRY,
    pub EntryCount: DWORD,
    pub ContentionCount: DWORD,
    pub Flags: DWORD,
    pub CreatorBackTraceIndexHigh: WORD,
    pub SpareWORD: WORD,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION_DEBUG() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_CRITICAL_SECTION_DEBUG> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        48usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreatorBackTraceIndex) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CriticalSection) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CriticalSection)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ProcessLocksList) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ProcessLocksList)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EntryCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(EntryCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ContentionCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ContentionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreatorBackTraceIndexHigh) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndexHigh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpareWORD) as usize - ptr as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(SpareWORD)
        )
    );
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: HANDLE,
    pub LockSemaphore: HANDLE,
    pub SpinCount: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_CRITICAL_SECTION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        40usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(DebugInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LockSemaphore) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockSemaphore)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SpinCount) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(SpinCount)
        )
    );
}
impl Default for _RTL_CRITICAL_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
    const UNINIT: ::std::mem::MaybeUninit<_RTL_SRWLOCK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_SRWLOCK),
            "::",
            stringify!(Ptr)
        )
    );
}
impl Default for _RTL_SRWLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
    const UNINIT: ::std::mem::MaybeUninit<_FILETIME> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILETIME>(),
        8usize,
        concat!("Size of: ", stringify!(_FILETIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILETIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILETIME))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwLowDateTime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwLowDateTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwHighDateTime) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwHighDateTime)
        )
    );
}
pub type PFILETIME = *mut _FILETIME;
pub type CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub type SRWLOCK = RTL_SRWLOCK;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SERVICE_STATUS_HANDLE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SERVICE_STATUS_HANDLE__() {
    const UNINIT: ::std::mem::MaybeUninit<SERVICE_STATUS_HANDLE__> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SERVICE_STATUS_HANDLE__>(),
        4usize,
        concat!("Size of: ", stringify!(SERVICE_STATUS_HANDLE__))
    );
    assert_eq!(
        ::std::mem::align_of::<SERVICE_STATUS_HANDLE__>(),
        4usize,
        concat!("Alignment of ", stringify!(SERVICE_STATUS_HANDLE__))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_STATUS_HANDLE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type SERVICE_STATUS_HANDLE = *mut SERVICE_STATUS_HANDLE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SERVICE_STATUS {
    pub dwServiceType: DWORD,
    pub dwCurrentState: DWORD,
    pub dwControlsAccepted: DWORD,
    pub dwWin32ExitCode: DWORD,
    pub dwServiceSpecificExitCode: DWORD,
    pub dwCheckPoint: DWORD,
    pub dwWaitHint: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS() {
    const UNINIT: ::std::mem::MaybeUninit<_SERVICE_STATUS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SERVICE_STATUS>(),
        28usize,
        concat!("Size of: ", stringify!(_SERVICE_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SERVICE_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SERVICE_STATUS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwServiceType) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwServiceType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwCurrentState) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwCurrentState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwControlsAccepted) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwControlsAccepted)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwWin32ExitCode) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwWin32ExitCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwServiceSpecificExitCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwServiceSpecificExitCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwCheckPoint) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwCheckPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dwWaitHint) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwWaitHint)
        )
    );
}
pub type SERVICE_STATUS = _SERVICE_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_STATUS_BLOCK__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
        )
    );
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_STATUS_BLOCK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_STATUS_BLOCK>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
        )
    );
}
impl Default for _IO_STATUS_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
extern "C" {
    pub static FspFsctlDeviceClassGuid: GUID;
}
extern "C" {
    pub static FspFsvrtDeviceClassGuid: GUID;
}
pub const FspFsctlTransactReservedKind: _bindgen_ty_5 = 0;
pub const FspFsctlTransactCreateKind: _bindgen_ty_5 = 1;
pub const FspFsctlTransactOverwriteKind: _bindgen_ty_5 = 2;
pub const FspFsctlTransactCleanupKind: _bindgen_ty_5 = 3;
pub const FspFsctlTransactCloseKind: _bindgen_ty_5 = 4;
pub const FspFsctlTransactReadKind: _bindgen_ty_5 = 5;
pub const FspFsctlTransactWriteKind: _bindgen_ty_5 = 6;
pub const FspFsctlTransactQueryInformationKind: _bindgen_ty_5 = 7;
pub const FspFsctlTransactSetInformationKind: _bindgen_ty_5 = 8;
pub const FspFsctlTransactQueryEaKind: _bindgen_ty_5 = 9;
pub const FspFsctlTransactSetEaKind: _bindgen_ty_5 = 10;
pub const FspFsctlTransactFlushBuffersKind: _bindgen_ty_5 = 11;
pub const FspFsctlTransactQueryVolumeInformationKind: _bindgen_ty_5 = 12;
pub const FspFsctlTransactSetVolumeInformationKind: _bindgen_ty_5 = 13;
pub const FspFsctlTransactQueryDirectoryKind: _bindgen_ty_5 = 14;
pub const FspFsctlTransactFileSystemControlKind: _bindgen_ty_5 = 15;
pub const FspFsctlTransactDeviceControlKind: _bindgen_ty_5 = 16;
pub const FspFsctlTransactShutdownKind: _bindgen_ty_5 = 17;
pub const FspFsctlTransactLockControlKind: _bindgen_ty_5 = 18;
pub const FspFsctlTransactQuerySecurityKind: _bindgen_ty_5 = 19;
pub const FspFsctlTransactSetSecurityKind: _bindgen_ty_5 = 20;
pub const FspFsctlTransactQueryStreamInformationKind: _bindgen_ty_5 = 21;
pub const FspFsctlTransactKindCount: _bindgen_ty_5 = 22;
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
pub const FspFsctlTransactTimeoutMinimum: _bindgen_ty_6 = 1000;
pub const FspFsctlTransactTimeoutMaximum: _bindgen_ty_6 = 10000;
pub const FspFsctlTransactTimeoutDefault: _bindgen_ty_6 = 1000;
pub const FspFsctlIrpTimeoutMinimum: _bindgen_ty_6 = 60000;
pub const FspFsctlIrpTimeoutMaximum: _bindgen_ty_6 = 600000;
pub const FspFsctlIrpTimeoutDefault: _bindgen_ty_6 = 300000;
pub const FspFsctlIrpTimeoutDebug: _bindgen_ty_6 = 142;
pub const FspFsctlIrpCapacityMinimum: _bindgen_ty_6 = 100;
pub const FspFsctlIrpCapacityMaximum: _bindgen_ty_6 = 1000;
pub const FspFsctlIrpCapacityDefault: _bindgen_ty_6 = 1000;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_FSCTL_VOLUME_PARAMS_V0 {
    pub Version: UINT16,
    pub SectorSize: UINT16,
    pub SectorsPerAllocationUnit: UINT16,
    pub MaxComponentLength: UINT16,
    pub VolumeCreationTime: UINT64,
    pub VolumeSerialNumber: UINT32,
    pub TransactTimeout: UINT32,
    pub IrpTimeout: UINT32,
    pub IrpCapacity: UINT32,
    pub FileInfoTimeout: UINT32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Prefix: [WCHAR; 192usize],
    pub FileSystemName: [WCHAR; 16usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_VOLUME_PARAMS_V0() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_VOLUME_PARAMS_V0> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_VOLUME_PARAMS_V0>(),
        456usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_VOLUME_PARAMS_V0))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_VOLUME_PARAMS_V0>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_VOLUME_PARAMS_V0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(SectorSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxComponentLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(MaxComponentLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(VolumeCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(VolumeSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactTimeout) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(TransactTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IrpTimeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(IrpTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IrpCapacity) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(IrpCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfoTimeout) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(FileInfoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prefix) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(Prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(FileSystemName)
        )
    );
}
impl Default for FSP_FSCTL_VOLUME_PARAMS_V0 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FSP_FSCTL_VOLUME_PARAMS_V0 {
    #[inline]
    pub fn CaseSensitiveSearch(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitiveSearch(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedNames(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedNames(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnicodeOnDisk(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnicodeOnDisk(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistentAcls(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistentAcls(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePoints(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePoints(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePointsAccessCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePointsAccessCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NamedStreams(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NamedStreams(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardLinks(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardLinks(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnlyVolume(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnlyVolume(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostCleanupWhenModifiedOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostCleanupWhenModifiedOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryPattern(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryPattern(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AlwaysUseDoubleBuffering(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AlwaysUseDoubleBuffering(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryFileName(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryFileName(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlushAndPurgeOnCleanup(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlushAndPurgeOnCleanup(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceControl(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceControl(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsUserContext2(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsUserContext2(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsFullContext(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsFullContext(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmNoReparsePointsDirCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmNoReparsePointsDirCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_UmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowOpenInKernelMode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowOpenInKernelMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WslFeatures(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WslFeatures(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectoryMarkerAsNextOffset(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectoryMarkerAsNextOffset(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RejectIrpPriorToTransact0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RejectIrpPriorToTransact0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsPosixUnlinkRename(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsPosixUnlinkRename(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostDispositionWhenNecessaryOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostDispositionWhenNecessaryOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseSensitiveSearch: UINT32,
        CasePreservedNames: UINT32,
        UnicodeOnDisk: UINT32,
        PersistentAcls: UINT32,
        ReparsePoints: UINT32,
        ReparsePointsAccessCheck: UINT32,
        NamedStreams: UINT32,
        HardLinks: UINT32,
        ExtendedAttributes: UINT32,
        ReadOnlyVolume: UINT32,
        PostCleanupWhenModifiedOnly: UINT32,
        PassQueryDirectoryPattern: UINT32,
        AlwaysUseDoubleBuffering: UINT32,
        PassQueryDirectoryFileName: UINT32,
        FlushAndPurgeOnCleanup: UINT32,
        DeviceControl: UINT32,
        UmFileContextIsUserContext2: UINT32,
        UmFileContextIsFullContext: UINT32,
        UmNoReparsePointsDirCheck: UINT32,
        UmReservedFlags: UINT32,
        AllowOpenInKernelMode: UINT32,
        CasePreservedExtendedAttributes: UINT32,
        WslFeatures: UINT32,
        DirectoryMarkerAsNextOffset: UINT32,
        RejectIrpPriorToTransact0: UINT32,
        SupportsPosixUnlinkRename: UINT32,
        PostDispositionWhenNecessaryOnly: UINT32,
        KmReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseSensitiveSearch: u32 = unsafe { ::std::mem::transmute(CaseSensitiveSearch) };
            CaseSensitiveSearch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CasePreservedNames: u32 = unsafe { ::std::mem::transmute(CasePreservedNames) };
            CasePreservedNames as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UnicodeOnDisk: u32 = unsafe { ::std::mem::transmute(UnicodeOnDisk) };
            UnicodeOnDisk as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PersistentAcls: u32 = unsafe { ::std::mem::transmute(PersistentAcls) };
            PersistentAcls as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReparsePoints: u32 = unsafe { ::std::mem::transmute(ReparsePoints) };
            ReparsePoints as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ReparsePointsAccessCheck: u32 =
                unsafe { ::std::mem::transmute(ReparsePointsAccessCheck) };
            ReparsePointsAccessCheck as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NamedStreams: u32 = unsafe { ::std::mem::transmute(NamedStreams) };
            NamedStreams as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HardLinks: u32 = unsafe { ::std::mem::transmute(HardLinks) };
            HardLinks as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ExtendedAttributes: u32 = unsafe { ::std::mem::transmute(ExtendedAttributes) };
            ExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ReadOnlyVolume: u32 = unsafe { ::std::mem::transmute(ReadOnlyVolume) };
            ReadOnlyVolume as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PostCleanupWhenModifiedOnly: u32 =
                unsafe { ::std::mem::transmute(PostCleanupWhenModifiedOnly) };
            PostCleanupWhenModifiedOnly as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PassQueryDirectoryPattern: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryPattern) };
            PassQueryDirectoryPattern as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let AlwaysUseDoubleBuffering: u32 =
                unsafe { ::std::mem::transmute(AlwaysUseDoubleBuffering) };
            AlwaysUseDoubleBuffering as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PassQueryDirectoryFileName: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryFileName) };
            PassQueryDirectoryFileName as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FlushAndPurgeOnCleanup: u32 =
                unsafe { ::std::mem::transmute(FlushAndPurgeOnCleanup) };
            FlushAndPurgeOnCleanup as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DeviceControl: u32 = unsafe { ::std::mem::transmute(DeviceControl) };
            DeviceControl as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UmFileContextIsUserContext2: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsUserContext2) };
            UmFileContextIsUserContext2 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UmFileContextIsFullContext: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsFullContext) };
            UmFileContextIsFullContext as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let UmNoReparsePointsDirCheck: u32 =
                unsafe { ::std::mem::transmute(UmNoReparsePointsDirCheck) };
            UmNoReparsePointsDirCheck as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let UmReservedFlags: u32 = unsafe { ::std::mem::transmute(UmReservedFlags) };
            UmReservedFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AllowOpenInKernelMode: u32 =
                unsafe { ::std::mem::transmute(AllowOpenInKernelMode) };
            AllowOpenInKernelMode as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CasePreservedExtendedAttributes: u32 =
                unsafe { ::std::mem::transmute(CasePreservedExtendedAttributes) };
            CasePreservedExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let WslFeatures: u32 = unsafe { ::std::mem::transmute(WslFeatures) };
            WslFeatures as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let DirectoryMarkerAsNextOffset: u32 =
                unsafe { ::std::mem::transmute(DirectoryMarkerAsNextOffset) };
            DirectoryMarkerAsNextOffset as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RejectIrpPriorToTransact0: u32 =
                unsafe { ::std::mem::transmute(RejectIrpPriorToTransact0) };
            RejectIrpPriorToTransact0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let SupportsPosixUnlinkRename: u32 =
                unsafe { ::std::mem::transmute(SupportsPosixUnlinkRename) };
            SupportsPosixUnlinkRename as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PostDispositionWhenNecessaryOnly: u32 =
                unsafe { ::std::mem::transmute(PostDispositionWhenNecessaryOnly) };
            PostDispositionWhenNecessaryOnly as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let KmReservedFlags: u32 = unsafe { ::std::mem::transmute(KmReservedFlags) };
            KmReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_FSCTL_VOLUME_PARAMS {
    pub Version: UINT16,
    pub SectorSize: UINT16,
    pub SectorsPerAllocationUnit: UINT16,
    pub MaxComponentLength: UINT16,
    pub VolumeCreationTime: UINT64,
    pub VolumeSerialNumber: UINT32,
    pub TransactTimeout: UINT32,
    pub IrpTimeout: UINT32,
    pub IrpCapacity: UINT32,
    pub FileInfoTimeout: UINT32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Prefix: [WCHAR; 192usize],
    pub FileSystemName: [WCHAR; 16usize],
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub VolumeInfoTimeout: UINT32,
    pub DirInfoTimeout: UINT32,
    pub SecurityTimeout: UINT32,
    pub StreamInfoTimeout: UINT32,
    pub EaTimeout: UINT32,
    pub FsextControlCode: UINT32,
    pub Reserved32: [UINT32; 1usize],
    pub Reserved64: [UINT64; 2usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_VOLUME_PARAMS() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_VOLUME_PARAMS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_VOLUME_PARAMS>(),
        504usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_VOLUME_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_VOLUME_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_VOLUME_PARAMS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(SectorSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(SectorsPerAllocationUnit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MaxComponentLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(MaxComponentLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(VolumeCreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(VolumeSerialNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TransactTimeout) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(TransactTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IrpTimeout) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(IrpTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IrpCapacity) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(IrpCapacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfoTimeout) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(FileInfoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Prefix) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Prefix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(FileSystemName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeInfoTimeout) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(VolumeInfoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DirInfoTimeout) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(DirInfoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityTimeout) as usize - ptr as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(SecurityTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamInfoTimeout) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(StreamInfoTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaTimeout) as usize - ptr as usize },
        476usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(EaTimeout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FsextControlCode) as usize - ptr as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(FsextControlCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved32) as usize - ptr as usize },
        484usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Reserved32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved64) as usize - ptr as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Reserved64)
        )
    );
}
impl Default for FSP_FSCTL_VOLUME_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FSP_FSCTL_VOLUME_PARAMS {
    #[inline]
    pub fn CaseSensitiveSearch(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitiveSearch(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedNames(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedNames(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnicodeOnDisk(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnicodeOnDisk(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistentAcls(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistentAcls(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePoints(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePoints(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePointsAccessCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePointsAccessCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NamedStreams(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NamedStreams(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardLinks(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardLinks(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnlyVolume(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnlyVolume(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostCleanupWhenModifiedOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostCleanupWhenModifiedOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryPattern(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryPattern(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AlwaysUseDoubleBuffering(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AlwaysUseDoubleBuffering(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryFileName(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryFileName(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlushAndPurgeOnCleanup(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlushAndPurgeOnCleanup(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceControl(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceControl(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsUserContext2(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsUserContext2(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsFullContext(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsFullContext(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmNoReparsePointsDirCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmNoReparsePointsDirCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_UmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowOpenInKernelMode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowOpenInKernelMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WslFeatures(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WslFeatures(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectoryMarkerAsNextOffset(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectoryMarkerAsNextOffset(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RejectIrpPriorToTransact0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RejectIrpPriorToTransact0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsPosixUnlinkRename(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsPosixUnlinkRename(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostDispositionWhenNecessaryOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostDispositionWhenNecessaryOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseSensitiveSearch: UINT32,
        CasePreservedNames: UINT32,
        UnicodeOnDisk: UINT32,
        PersistentAcls: UINT32,
        ReparsePoints: UINT32,
        ReparsePointsAccessCheck: UINT32,
        NamedStreams: UINT32,
        HardLinks: UINT32,
        ExtendedAttributes: UINT32,
        ReadOnlyVolume: UINT32,
        PostCleanupWhenModifiedOnly: UINT32,
        PassQueryDirectoryPattern: UINT32,
        AlwaysUseDoubleBuffering: UINT32,
        PassQueryDirectoryFileName: UINT32,
        FlushAndPurgeOnCleanup: UINT32,
        DeviceControl: UINT32,
        UmFileContextIsUserContext2: UINT32,
        UmFileContextIsFullContext: UINT32,
        UmNoReparsePointsDirCheck: UINT32,
        UmReservedFlags: UINT32,
        AllowOpenInKernelMode: UINT32,
        CasePreservedExtendedAttributes: UINT32,
        WslFeatures: UINT32,
        DirectoryMarkerAsNextOffset: UINT32,
        RejectIrpPriorToTransact0: UINT32,
        SupportsPosixUnlinkRename: UINT32,
        PostDispositionWhenNecessaryOnly: UINT32,
        KmReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseSensitiveSearch: u32 = unsafe { ::std::mem::transmute(CaseSensitiveSearch) };
            CaseSensitiveSearch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CasePreservedNames: u32 = unsafe { ::std::mem::transmute(CasePreservedNames) };
            CasePreservedNames as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UnicodeOnDisk: u32 = unsafe { ::std::mem::transmute(UnicodeOnDisk) };
            UnicodeOnDisk as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PersistentAcls: u32 = unsafe { ::std::mem::transmute(PersistentAcls) };
            PersistentAcls as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReparsePoints: u32 = unsafe { ::std::mem::transmute(ReparsePoints) };
            ReparsePoints as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ReparsePointsAccessCheck: u32 =
                unsafe { ::std::mem::transmute(ReparsePointsAccessCheck) };
            ReparsePointsAccessCheck as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NamedStreams: u32 = unsafe { ::std::mem::transmute(NamedStreams) };
            NamedStreams as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HardLinks: u32 = unsafe { ::std::mem::transmute(HardLinks) };
            HardLinks as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ExtendedAttributes: u32 = unsafe { ::std::mem::transmute(ExtendedAttributes) };
            ExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ReadOnlyVolume: u32 = unsafe { ::std::mem::transmute(ReadOnlyVolume) };
            ReadOnlyVolume as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PostCleanupWhenModifiedOnly: u32 =
                unsafe { ::std::mem::transmute(PostCleanupWhenModifiedOnly) };
            PostCleanupWhenModifiedOnly as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PassQueryDirectoryPattern: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryPattern) };
            PassQueryDirectoryPattern as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let AlwaysUseDoubleBuffering: u32 =
                unsafe { ::std::mem::transmute(AlwaysUseDoubleBuffering) };
            AlwaysUseDoubleBuffering as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PassQueryDirectoryFileName: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryFileName) };
            PassQueryDirectoryFileName as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FlushAndPurgeOnCleanup: u32 =
                unsafe { ::std::mem::transmute(FlushAndPurgeOnCleanup) };
            FlushAndPurgeOnCleanup as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DeviceControl: u32 = unsafe { ::std::mem::transmute(DeviceControl) };
            DeviceControl as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UmFileContextIsUserContext2: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsUserContext2) };
            UmFileContextIsUserContext2 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UmFileContextIsFullContext: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsFullContext) };
            UmFileContextIsFullContext as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let UmNoReparsePointsDirCheck: u32 =
                unsafe { ::std::mem::transmute(UmNoReparsePointsDirCheck) };
            UmNoReparsePointsDirCheck as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let UmReservedFlags: u32 = unsafe { ::std::mem::transmute(UmReservedFlags) };
            UmReservedFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AllowOpenInKernelMode: u32 =
                unsafe { ::std::mem::transmute(AllowOpenInKernelMode) };
            AllowOpenInKernelMode as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CasePreservedExtendedAttributes: u32 =
                unsafe { ::std::mem::transmute(CasePreservedExtendedAttributes) };
            CasePreservedExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let WslFeatures: u32 = unsafe { ::std::mem::transmute(WslFeatures) };
            WslFeatures as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let DirectoryMarkerAsNextOffset: u32 =
                unsafe { ::std::mem::transmute(DirectoryMarkerAsNextOffset) };
            DirectoryMarkerAsNextOffset as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RejectIrpPriorToTransact0: u32 =
                unsafe { ::std::mem::transmute(RejectIrpPriorToTransact0) };
            RejectIrpPriorToTransact0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let SupportsPosixUnlinkRename: u32 =
                unsafe { ::std::mem::transmute(SupportsPosixUnlinkRename) };
            SupportsPosixUnlinkRename as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PostDispositionWhenNecessaryOnly: u32 =
                unsafe { ::std::mem::transmute(PostDispositionWhenNecessaryOnly) };
            PostDispositionWhenNecessaryOnly as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let KmReservedFlags: u32 = unsafe { ::std::mem::transmute(KmReservedFlags) };
            KmReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn VolumeInfoTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VolumeInfoTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirInfoTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirInfoTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecurityTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StreamInfoTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StreamInfoTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EaTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EaTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KmAdditionalReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_KmAdditionalReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        VolumeInfoTimeoutValid: UINT32,
        DirInfoTimeoutValid: UINT32,
        SecurityTimeoutValid: UINT32,
        StreamInfoTimeoutValid: UINT32,
        EaTimeoutValid: UINT32,
        KmAdditionalReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VolumeInfoTimeoutValid: u32 =
                unsafe { ::std::mem::transmute(VolumeInfoTimeoutValid) };
            VolumeInfoTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DirInfoTimeoutValid: u32 = unsafe { ::std::mem::transmute(DirInfoTimeoutValid) };
            DirInfoTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SecurityTimeoutValid: u32 = unsafe { ::std::mem::transmute(SecurityTimeoutValid) };
            SecurityTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let StreamInfoTimeoutValid: u32 =
                unsafe { ::std::mem::transmute(StreamInfoTimeoutValid) };
            StreamInfoTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EaTimeoutValid: u32 = unsafe { ::std::mem::transmute(EaTimeoutValid) };
            EaTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let KmAdditionalReservedFlags: u32 =
                unsafe { ::std::mem::transmute(KmAdditionalReservedFlags) };
            KmAdditionalReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_VOLUME_INFO {
    pub TotalSize: UINT64,
    pub FreeSize: UINT64,
    pub VolumeLabelLength: UINT16,
    pub VolumeLabel: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_VOLUME_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_VOLUME_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_VOLUME_INFO>(),
        88usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_VOLUME_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_VOLUME_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_VOLUME_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TotalSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(TotalSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FreeSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(FreeSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(VolumeLabelLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_FILE_INFO {
    pub FileAttributes: UINT32,
    pub ReparseTag: UINT32,
    pub AllocationSize: UINT64,
    pub FileSize: UINT64,
    pub CreationTime: UINT64,
    pub LastAccessTime: UINT64,
    pub LastWriteTime: UINT64,
    pub ChangeTime: UINT64,
    pub IndexNumber: UINT64,
    pub HardLinks: UINT32,
    pub EaSize: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_FILE_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_FILE_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_FILE_INFO>(),
        72usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_FILE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_FILE_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_FILE_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(ReparseTag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(ChangeTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IndexNumber) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(IndexNumber)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HardLinks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(HardLinks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(EaSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_FSCTL_OPEN_FILE_INFO {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub NormalizedName: PWSTR,
    pub NormalizedNameSize: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_OPEN_FILE_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_OPEN_FILE_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_OPEN_FILE_INFO>(),
        88usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_OPEN_FILE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_OPEN_FILE_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_OPEN_FILE_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_OPEN_FILE_INFO),
            "::",
            stringify!(FileInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NormalizedName) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_OPEN_FILE_INFO),
            "::",
            stringify!(NormalizedName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NormalizedNameSize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_OPEN_FILE_INFO),
            "::",
            stringify!(NormalizedNameSize)
        )
    );
}
impl Default for FSP_FSCTL_OPEN_FILE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct FSP_FSCTL_DIR_INFO {
    pub Size: UINT16,
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub __bindgen_anon_1: FSP_FSCTL_DIR_INFO__bindgen_ty_1,
    pub FileNameBuf: __IncompleteArrayField<WCHAR>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_DIR_INFO__bindgen_ty_1 {
    pub NextOffset: UINT64,
    pub Padding: [UINT8; 24usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_DIR_INFO__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_DIR_INFO__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_DIR_INFO__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_DIR_INFO__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1),
            "::",
            stringify!(NextOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1),
            "::",
            stringify!(Padding)
        )
    );
}
impl Default for FSP_FSCTL_DIR_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_DIR_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_DIR_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_DIR_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_DIR_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_DIR_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_DIR_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO),
            "::",
            stringify!(FileInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameBuf) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO),
            "::",
            stringify!(FileNameBuf)
        )
    );
}
impl Default for FSP_FSCTL_DIR_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct FSP_FSCTL_STREAM_INFO {
    pub Size: UINT16,
    pub StreamSize: UINT64,
    pub StreamAllocationSize: UINT64,
    pub StreamNameBuf: __IncompleteArrayField<WCHAR>,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_STREAM_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_STREAM_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_STREAM_INFO>(),
        24usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_STREAM_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_STREAM_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_STREAM_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(StreamSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamAllocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(StreamAllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StreamNameBuf) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(StreamNameBuf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct FSP_FSCTL_NOTIFY_INFO {
    pub Size: UINT16,
    pub Filter: UINT32,
    pub Action: UINT32,
    pub FileNameBuf: __IncompleteArrayField<WCHAR>,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_NOTIFY_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_NOTIFY_INFO> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_NOTIFY_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_NOTIFY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_NOTIFY_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_NOTIFY_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Filter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(Filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileNameBuf) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(FileNameBuf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_FULL_CONTEXT {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_FULL_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_FULL_CONTEXT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_FULL_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_FULL_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_BUF {
    pub Offset: UINT16,
    pub Size: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_BUF() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_BUF> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_BUF>(),
        4usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_BUF))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_BUF>(),
        2usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_BUF))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_BUF),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_BUF),
            "::",
            stringify!(Size)
        )
    );
}
#[repr(C)]
pub struct FSP_FSCTL_TRANSACT_REQ {
    pub Version: UINT16,
    pub Size: UINT16,
    pub Kind: UINT32,
    pub Hint: UINT64,
    pub Req: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1,
    pub FileName: FSP_FSCTL_TRANSACT_BUF,
    pub __bindgen_padding_0: [u8; 4usize],
    pub Buffer: __IncompleteArrayField<UINT8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1 {
    pub Create: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
    pub Overwrite: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
    pub Cleanup: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3,
    pub Close: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4,
    pub Read: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
    pub Write: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
    pub QueryInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7,
    pub SetInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8,
    pub QueryEa: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9,
    pub SetEa: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10,
    pub FlushBuffers: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11,
    pub SetVolumeInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12,
    pub QueryDirectory: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
    pub FileSystemControl: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
    pub DeviceControl: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
    pub QuerySecurity: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16,
    pub SetSecurity: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17,
    pub QueryStreamInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1 {
    pub CreateOptions: UINT32,
    pub FileAttributes: UINT32,
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
    pub AllocationSize: UINT64,
    pub AccessToken: UINT64,
    pub DesiredAccess: UINT32,
    pub GrantedAccess: UINT32,
    pub ShareAccess: UINT32,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub NamedStream: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateOptions) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CreateOptions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AccessToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DesiredAccess) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DesiredAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(GrantedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ShareAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Ea)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NamedStream) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(NamedStream)
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn UserMode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasTraversePrivilege(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasTraversePrivilege(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasBackupPrivilege(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasBackupPrivilege(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasRestorePrivilege(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasRestorePrivilege(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OpenTargetDirectory(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OpenTargetDirectory(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CaseSensitive(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitive(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasTrailingBackslash(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasTrailingBackslash(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AcceptsSecurityDescriptor(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcceptsSecurityDescriptor(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EaIsReparsePoint(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EaIsReparsePoint(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UserMode: UINT32,
        HasTraversePrivilege: UINT32,
        HasBackupPrivilege: UINT32,
        HasRestorePrivilege: UINT32,
        OpenTargetDirectory: UINT32,
        CaseSensitive: UINT32,
        HasTrailingBackslash: UINT32,
        AcceptsSecurityDescriptor: UINT32,
        EaIsReparsePoint: UINT32,
        ReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UserMode: u32 = unsafe { ::std::mem::transmute(UserMode) };
            UserMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HasTraversePrivilege: u32 = unsafe { ::std::mem::transmute(HasTraversePrivilege) };
            HasTraversePrivilege as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HasBackupPrivilege: u32 = unsafe { ::std::mem::transmute(HasBackupPrivilege) };
            HasBackupPrivilege as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let HasRestorePrivilege: u32 = unsafe { ::std::mem::transmute(HasRestorePrivilege) };
            HasRestorePrivilege as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OpenTargetDirectory: u32 = unsafe { ::std::mem::transmute(OpenTargetDirectory) };
            OpenTargetDirectory as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CaseSensitive: u32 = unsafe { ::std::mem::transmute(CaseSensitive) };
            CaseSensitive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HasTrailingBackslash: u32 = unsafe { ::std::mem::transmute(HasTrailingBackslash) };
            HasTrailingBackslash as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AcceptsSecurityDescriptor: u32 =
                unsafe { ::std::mem::transmute(AcceptsSecurityDescriptor) };
            AcceptsSecurityDescriptor as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EaIsReparsePoint: u32 = unsafe { ::std::mem::transmute(EaIsReparsePoint) };
            EaIsReparsePoint as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub FileAttributes: UINT32,
    pub AllocationSize: UINT64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(AllocationSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Ea)
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn Supersede(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Supersede(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Supersede: UINT32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Supersede: u32 = unsafe { ::std::mem::transmute(Supersede) };
            Supersede as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(UserContext2)
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn Delete(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Delete(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetAllocationSize(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetAllocationSize(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetArchiveBit(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetArchiveBit(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetLastAccessTime(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetLastAccessTime(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetLastWriteTime(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetLastWriteTime(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetChangeTime(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetChangeTime(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Delete: UINT32,
        SetAllocationSize: UINT32,
        SetArchiveBit: UINT32,
        SetLastAccessTime: UINT32,
        SetLastWriteTime: UINT32,
        SetChangeTime: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Delete: u32 = unsafe { ::std::mem::transmute(Delete) };
            Delete as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SetAllocationSize: u32 = unsafe { ::std::mem::transmute(SetAllocationSize) };
            SetAllocationSize as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SetArchiveBit: u32 = unsafe { ::std::mem::transmute(SetArchiveBit) };
            SetArchiveBit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SetLastAccessTime: u32 = unsafe { ::std::mem::transmute(SetLastAccessTime) };
            SetLastAccessTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SetLastWriteTime: u32 = unsafe { ::std::mem::transmute(SetLastWriteTime) };
            SetLastWriteTime as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SetChangeTime: u32 = unsafe { ::std::mem::transmute(SetChangeTime) };
            SetChangeTime as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Address: UINT64,
    pub Offset: UINT64,
    pub Length: UINT32,
    pub Key: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Address: UINT64,
    pub Offset: UINT64,
    pub Length: UINT32,
    pub Key: UINT32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Key)
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6 {
    #[inline]
    pub fn ConstrainedIo(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConstrainedIo(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ConstrainedIo: UINT32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ConstrainedIo: u32 = unsafe { ::std::mem::transmute(ConstrainedIo) };
            ConstrainedIo as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub FileInformationClass: UINT32,
    pub Info: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    pub Allocation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
    pub Basic: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
    pub Disposition: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3,
    pub DispositionEx:
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
    pub EndOfFile: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
    pub Rename: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
    pub RenameEx: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1 {
    pub AllocationSize: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(AllocationSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2 {
    pub FileAttributes: UINT32,
    pub CreationTime: UINT64,
    pub LastAccessTime: UINT64,
    pub LastWriteTime: UINT64,
    pub ChangeTime: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
        >(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(LastWriteTime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            ),
            "::",
            stringify!(ChangeTime)
        )
    );
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3
            )
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn Delete(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Delete(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Delete: UINT32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Delete: u32 = unsafe { ::std::mem::transmute(Delete) };
            Delete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4 {
    pub Flags: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4
            ),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5 {
    pub FileSize: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5
            ),
            "::",
            stringify!(FileSize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6 {
    pub NewFileName: FSP_FSCTL_TRANSACT_BUF,
    pub AccessToken: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
        >(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NewFileName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
            ),
            "::",
            stringify!(NewFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
            ),
            "::",
            stringify!(AccessToken)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7 {
    pub NewFileName: FSP_FSCTL_TRANSACT_BUF,
    pub AccessToken: UINT64,
    pub Flags: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
        >(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
        >(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NewFileName) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            ),
            "::",
            stringify!(NewFileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            ),
            "::",
            stringify!(AccessToken)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            ),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Allocation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Allocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Basic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Basic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Disposition) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Disposition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DispositionEx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(DispositionEx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(EndOfFile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rename) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Rename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RenameEx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(RenameEx)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(FileInformationClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Info) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Info)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Ea)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12 {
    pub FsInformationClass: UINT32,
    pub Info: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    pub Label: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1 {
    pub VolumeLabel: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1(
) {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(VolumeLabel)
        )
    );
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Label) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(Label)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FsInformationClass) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(FsInformationClass)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Info) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Info)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Address: UINT64,
    pub Length: UINT32,
    pub Pattern: FSP_FSCTL_TRANSACT_BUF,
    pub Marker: FSP_FSCTL_TRANSACT_BUF,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Pattern) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Pattern)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Marker) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Marker)
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13 {
    #[inline]
    pub fn CaseSensitive(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitive(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PatternIsFileName(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PatternIsFileName(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseSensitive: UINT32,
        PatternIsFileName: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseSensitive: u32 = unsafe { ::std::mem::transmute(CaseSensitive) };
            CaseSensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PatternIsFileName: u32 = unsafe { ::std::mem::transmute(PatternIsFileName) };
            PatternIsFileName as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub FsControlCode: UINT32,
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
    pub TargetOnFileSystem: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(FsControlCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).TargetOnFileSystem) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(TargetOnFileSystem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub IoControlCode: UINT32,
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
    pub OutputLength: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(IoControlCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OutputLength) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(OutputLength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub SecurityInformation: UINT32,
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityInformation) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(SecurityInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(UserContext2)
        )
    );
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Overwrite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Overwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Cleanup) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Close) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Read) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryEa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetEa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FlushBuffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(FlushBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetVolumeInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetVolumeInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryDirectory) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(FileSystemControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(DeviceControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuerySecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QuerySecurity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetSecurity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryStreamInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryStreamInformation)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_REQ> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ>(),
        88usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_REQ))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_REQ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Req) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Req)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(FileName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Buffer)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_REQ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct FSP_FSCTL_TRANSACT_RSP {
    pub Version: UINT16,
    pub Size: UINT16,
    pub Kind: UINT32,
    pub Hint: UINT64,
    pub IoStatus: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1,
    pub Rsp: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2,
    pub Buffer: __IncompleteArrayField<UINT8>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1 {
    pub Information: UINT32,
    pub Status: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Information) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1),
            "::",
            stringify!(Information)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1),
            "::",
            stringify!(Status)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2 {
    pub Create: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1,
    pub Overwrite: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2,
    pub Write: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3,
    pub QueryInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4,
    pub SetInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5,
    pub QueryEa: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6,
    pub SetEa: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7,
    pub FlushBuffers: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8,
    pub QueryVolumeInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9,
    pub SetVolumeInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10,
    pub FileSystemControl: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11,
    pub DeviceControl: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12,
    pub QuerySecurity: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13,
    pub SetSecurity: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14,
    pub QueryStreamInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1 {
    pub Opened: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Reparse: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub GrantedAccess: UINT32,
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub FileName: FSP_FSCTL_TRANSACT_BUF,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(GrantedAccess)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileName)
        )
    );
}
impl FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableCache(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableCache(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasSecurityDescriptor(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasSecurityDescriptor(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableCache: UINT32,
        HasSecurityDescriptor: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableCache: u32 = unsafe { ::std::mem::transmute(DisableCache) };
            DisableCache as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HasSecurityDescriptor: u32 =
                unsafe { ::std::mem::transmute(HasSecurityDescriptor) };
            HasSecurityDescriptor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<
        FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Opened) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Opened)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reparse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Reparse)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(FileInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(FileInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(FileInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(FileInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6 {
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(Ea)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(FileInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(Ea)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(FileInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9 {
    pub VolumeInfo: FSP_FSCTL_VOLUME_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(VolumeInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10 {
    pub VolumeInfo: FSP_FSCTL_VOLUME_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10>(),
        88usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(VolumeInfo)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11),
            "::",
            stringify!(Buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12),
            "::",
            stringify!(Buffer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13 {
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14 {
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15),
            "::",
            stringify!(Buffer)
        )
    );
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Create) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(Create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Overwrite) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(Overwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Write) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(Write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryEa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetEa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FlushBuffers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(FlushBuffers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryVolumeInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryVolumeInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetVolumeInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetVolumeInformation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FileSystemControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(FileSystemControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeviceControl) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(DeviceControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QuerySecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QuerySecurity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetSecurity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).QueryStreamInformation) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryStreamInformation)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_FSCTL_TRANSACT_RSP> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP>(),
        128usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_RSP))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_RSP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Hint) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(IoStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Buffer)
        )
    );
}
impl Default for FSP_FSCTL_TRANSACT_RSP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn FspFsctlCreateVolume(
        DevicePath: PWSTR,
        VolumeParams: *const FSP_FSCTL_VOLUME_PARAMS,
        VolumeNameBuf: PWCHAR,
        VolumeNameSize: SIZE_T,
        PVolumeHandle: PHANDLE,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlMakeMountdev(
        VolumeHandle: HANDLE,
        Persistent: BOOLEAN,
        UniqueId: *mut GUID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlTransact(
        VolumeHandle: HANDLE,
        ResponseBuf: PVOID,
        ResponseBufSize: SIZE_T,
        RequestBuf: PVOID,
        PRequestBufSize: *mut SIZE_T,
        Batch: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlStop(VolumeHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlStop0(VolumeHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlNotify(
        VolumeHandle: HANDLE,
        NotifyInfo: *mut FSP_FSCTL_NOTIFY_INFO,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlGetVolumeList(
        DevicePath: PWSTR,
        VolumeListBuf: PWCHAR,
        PVolumeListSize: PSIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlPreflight(DevicePath: PWSTR) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_MOUNT_DESC {
    pub VolumeHandle: HANDLE,
    pub VolumeName: PWSTR,
    pub Security: PSECURITY_DESCRIPTOR,
    pub Reserved: UINT64,
    pub MountPoint: PWSTR,
    pub MountHandle: HANDLE,
}
#[test]
fn bindgen_test_layout_FSP_MOUNT_DESC() {
    const UNINIT: ::std::mem::MaybeUninit<FSP_MOUNT_DESC> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<FSP_MOUNT_DESC>(),
        48usize,
        concat!("Size of: ", stringify!(FSP_MOUNT_DESC))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_MOUNT_DESC>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_MOUNT_DESC))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeHandle) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(VolumeHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Security) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(Security)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MountPoint) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(MountPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MountHandle) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(MountHandle)
        )
    );
}
impl Default for FSP_MOUNT_DESC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn FspMountSet(Desc: *mut FSP_MOUNT_DESC) -> NTSTATUS;
}
extern "C" {
    pub fn FspMountRemove(Desc: *mut FSP_MOUNT_DESC) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    const UNINIT: ::std::mem::MaybeUninit<_FILE_FULL_EA_INFORMATION> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FILE_FULL_EA_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FULL_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaNameLength) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaNameLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaValueLength) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaValueLength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EaName) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaName)
        )
    );
}
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[doc = " @group File System\n\n A user mode file system is a program that uses the WinFsp API to expose a file system to\n Windows. The user mode file system must implement the operations in FSP_FILE_SYSTEM_INTERFACE,\n create a file system object using FspFileSystemCreate and start its dispatcher using\n FspFileSystemStartDispatcher. At that point it will start receiving file system requests on the\n FSP_FILE_SYSTEM_INTERFACE operations."]
pub type FSP_FILE_SYSTEM = _FSP_FILE_SYSTEM;
pub type FSP_FILE_SYSTEM_OPERATION_GUARD = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSP_FILE_SYSTEM,
        arg2: *mut FSP_FSCTL_TRANSACT_REQ,
        arg3: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS,
>;
pub type FSP_FILE_SYSTEM_OPERATION = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSP_FILE_SYSTEM,
        arg2: *mut FSP_FSCTL_TRANSACT_REQ,
        arg3: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS,
>;
pub const FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FINE:
    FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY = 0;
pub const FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_COARSE : FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY = 1 ;
#[doc = " User mode file system locking strategy.\n\n Two concurrency models are provided:\n\n 1. A fine-grained concurrency model where file system NAMESPACE accesses\n are guarded using an exclusive-shared (read-write) lock. File I/O is not\n guarded and concurrent reads/writes/etc. are possible. [Note that the FSD\n will still apply an exclusive-shared lock PER INDIVIDUAL FILE, but it will\n not limit I/O operations for different files.]\n\n The fine-grained concurrency model applies the exclusive-shared lock as\n follows:\n <ul>\n <li>EXCL: SetVolumeLabel, Flush(Volume),\n Create, Cleanup(Delete), SetInformation(Rename)</li>\n <li>SHRD: GetVolumeInfo, Open, SetInformation(Disposition), ReadDirectory</li>\n <li>NONE: all other operations</li>\n </ul>\n\n 2. A coarse-grained concurrency model where all file system accesses are\n guarded by a mutually exclusive lock.\n\n @see FspFileSystemSetOperationGuardStrategy"]
pub type FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY = ::std::os::raw::c_int;
pub const FspCleanupDelete: _bindgen_ty_7 = 1;
pub const FspCleanupSetAllocationSize: _bindgen_ty_7 = 2;
pub const FspCleanupSetArchiveBit: _bindgen_ty_7 = 16;
pub const FspCleanupSetLastAccessTime: _bindgen_ty_7 = 32;
pub const FspCleanupSetLastWriteTime: _bindgen_ty_7 = 64;
pub const FspCleanupSetChangeTime: _bindgen_ty_7 = 128;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
#[doc = " @class FSP_FILE_SYSTEM\n File system interface.\n\n The operations in this interface must be implemented by the user mode\n file system. Not all operations need be implemented. For example,\n a user mode file system that does not wish to support reparse points,\n need not implement the reparse point operations.\n\n Most of the operations accept a FileContext parameter. This parameter\n has different meanings depending on the value of the FSP_FSCTL_VOLUME_PARAMS\n flags UmFileContextIsUserContext2 and UmFileContextIsFullContext.\n\n There are three cases to consider:\n <ul>\n <li>When both of these flags are unset (default), the FileContext parameter\n represents the file node. The file node is a void pointer (or an integer\n that can fit in a pointer) that is used to uniquely identify an open file.\n Opening the same file name should always yield the same file node value\n for as long as the file with that name remains open anywhere in the system.\n </li>\n <li>When the UmFileContextIsUserContext2 is set, the FileContext parameter\n represents the file descriptor. The file descriptor is a void pointer (or\n an integer that can fit in a pointer) that is used to identify an open\n instance of a file. Opening the same file name may yield a different file\n descriptor.\n </li>\n <li>When the UmFileContextIsFullContext is set, the FileContext parameter\n is a pointer to a FSP_FSCTL_TRANSACT_FULL_CONTEXT. This allows a user mode\n file system to access the low-level UserContext and UserContext2 values.\n The UserContext is used to store the file node and the UserContext2 is\n used to store the file descriptor for an open file.\n </li>\n </ul>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FSP_FILE_SYSTEM_INTERFACE {
    #[doc = " Get volume information.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param VolumeInfo [out]\n     Pointer to a structure that will receive the volume information on successful return\n     from this call.\n @return\n     STATUS_SUCCESS or error code."]
    pub GetVolumeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            VolumeInfo: *mut FSP_FSCTL_VOLUME_INFO,
        ) -> NTSTATUS,
    >,
    pub SetVolumeLabelW: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            VolumeLabel: PWSTR,
            VolumeInfo: *mut FSP_FSCTL_VOLUME_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Get file or directory attributes and security descriptor given a file name.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileName\n     The name of the file or directory to get the attributes and security descriptor for.\n @param PFileAttributes\n     Pointer to a memory location that will receive the file attributes on successful return\n     from this call. May be NULL.\n\n     If this call returns STATUS_REPARSE, the file system MAY place here the index of the\n     first reparse point within FileName. The file system MAY also leave this at its default\n     value of 0.\n @param SecurityDescriptor\n     Pointer to a buffer that will receive the file security descriptor on successful return\n     from this call. May be NULL.\n @param PSecurityDescriptorSize [in,out]\n     Pointer to the security descriptor buffer size. On input it contains the size of the\n     security descriptor buffer. On output it will contain the actual size of the security\n     descriptor copied into the security descriptor buffer. May be NULL.\n @return\n     STATUS_SUCCESS, STATUS_REPARSE or error code.\n\n     STATUS_REPARSE should be returned by file systems that support reparse points when\n     they encounter a FileName that contains reparse points anywhere but the final path\n     component."]
    pub GetSecurityByName: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            PFileAttributes: PUINT32,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            PSecurityDescriptorSize: *mut SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Create new file or directory.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileName\n     The name of the file or directory to be created.\n @param CreateOptions\n     Create options for this request. This parameter has the same meaning as the\n     CreateOptions parameter of the NtCreateFile API. User mode file systems should typically\n     only be concerned with the flag FILE_DIRECTORY_FILE, which is an instruction to create a\n     directory rather than a file. Some file systems may also want to pay attention to the\n     FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH flags, although these are\n     typically handled by the FSD component.\n @param GrantedAccess\n     Determines the specific access rights that have been granted for this request. Upon\n     receiving this call all access checks have been performed and the user mode file system\n     need not perform any additional checks. However this parameter may be useful to a user\n     mode file system; for example the WinFsp-FUSE layer uses this parameter to determine\n     which flags to use in its POSIX open() call.\n @param FileAttributes\n     File attributes to apply to the newly created file or directory.\n @param SecurityDescriptor\n     Security descriptor to apply to the newly created file or directory. This security\n     descriptor will always be in self-relative format. Its length can be retrieved using the\n     Windows GetSecurityDescriptorLength API. Will be NULL for named streams.\n @param AllocationSize\n     Allocation size for the newly created file.\n @param PFileContext [out]\n     Pointer that will receive the file context on successful return from this call.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            CreateOptions: UINT32,
            GrantedAccess: UINT32,
            FileAttributes: UINT32,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            AllocationSize: UINT64,
            PFileContext: *mut PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Open a file or directory.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileName\n     The name of the file or directory to be opened.\n @param CreateOptions\n     Create options for this request. This parameter has the same meaning as the\n     CreateOptions parameter of the NtCreateFile API. User mode file systems typically\n     do not need to do anything special with respect to this parameter. Some file systems may\n     also want to pay attention to the FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH\n     flags, although these are typically handled by the FSD component.\n @param GrantedAccess\n     Determines the specific access rights that have been granted for this request. Upon\n     receiving this call all access checks have been performed and the user mode file system\n     need not perform any additional checks. However this parameter may be useful to a user\n     mode file system; for example the WinFsp-FUSE layer uses this parameter to determine\n     which flags to use in its POSIX open() call.\n @param PFileContext [out]\n     Pointer that will receive the file context on successful return from this call.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub Open: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            CreateOptions: UINT32,
            GrantedAccess: UINT32,
            PFileContext: *mut PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Overwrite a file.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to overwrite.\n @param FileAttributes\n     File attributes to apply to the overwritten file.\n @param ReplaceFileAttributes\n     When TRUE the existing file attributes should be replaced with the new ones.\n     When FALSE the existing file attributes should be merged (or'ed) with the new ones.\n @param AllocationSize\n     Allocation size for the overwritten file.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub Overwrite: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileAttributes: UINT32,
            ReplaceFileAttributes: BOOLEAN,
            AllocationSize: UINT64,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Cleanup a file.\n\n When CreateFile is used to open or create a file the kernel creates a kernel mode file\n object (type FILE_OBJECT) and a handle for it, which it returns to user-mode. The handle may\n be duplicated (using DuplicateHandle), but all duplicate handles always refer to the same\n file object. When all handles for a particular file object get closed (using CloseHandle)\n the system sends a Cleanup request to the file system.\n\n There will be a Cleanup operation for every Create or Open operation posted to the user mode\n file system. However the Cleanup operation is <b>not</b> the final close operation on a file.\n The file system must be ready to receive additional operations until close time. This is true\n even when the file is being deleted!\n\n The Flags parameter contains information about the cleanup operation:\n <ul>\n <li>FspCleanupDelete -\n An important function of the Cleanup operation is to complete a delete operation. Deleting\n a file or directory in Windows is a three-stage process where the file is first opened, then\n tested to see if the delete can proceed and if the answer is positive the file is then\n deleted during Cleanup.\n\n If the file system supports POSIX unlink (FSP_FSCTL_VOLUME_PARAMS ::\n SupportsPosixUnlinkRename), then a Cleanup / FspCleanupDelete operation may arrive while\n there are other open file handles for this particular file node. If the file system does not\n support POSIX unlink, then a Cleanup / FspCleanupDelete operation will always be the last\n outstanding cleanup for this particular file node.\n </li>\n <li>FspCleanupSetAllocationSize -\n The NTFS and FAT file systems reset a file's allocation size when they receive the last\n outstanding cleanup for a particular file node. User mode file systems that implement\n allocation size and wish to duplicate the NTFS and FAT behavior can use this flag.\n </li>\n <li>\n FspCleanupSetArchiveBit -\n File systems that support the archive bit should set the file node's archive bit when this\n flag is set.\n </li>\n <li>FspCleanupSetLastAccessTime, FspCleanupSetLastWriteTime, FspCleanupSetChangeTime - File\n systems should set the corresponding file time when each one of these flags is set. Note that\n updating the last access time is expensive and a file system may choose to not implement it.\n </ul>\n\n There is no way to report failure of this operation. This is a Windows limitation.\n\n As an optimization a file system may specify the FSP_FSCTL_VOLUME_PARAMS ::\n PostCleanupWhenModifiedOnly flag. In this case the FSD will only post Cleanup requests when\n the file was modified/deleted.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to cleanup.\n @param FileName\n     The name of the file or directory to cleanup. Sent only when a Delete is requested.\n @param Flags\n     These flags determine whether the file was modified and whether to delete the file.\n @see\n     Close\n     CanDelete\n     SetDelete"]
    pub Cleanup: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Flags: ULONG,
        ),
    >,
    #[doc = " Close a file.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to be closed."]
    pub Close: ::std::option::Option<
        unsafe extern "C" fn(FileSystem: *mut FSP_FILE_SYSTEM, FileContext: PVOID),
    >,
    #[doc = " Read a file.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to be read.\n @param Buffer\n     Pointer to a buffer that will receive the results of the read operation.\n @param Offset\n     Offset within the file to read from.\n @param Length\n     Length of data to read.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes read.\n @return\n     STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous\n     operation."]
    pub Read: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Buffer: PVOID,
            Offset: UINT64,
            Length: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Write a file.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to be written.\n @param Buffer\n     Pointer to a buffer that contains the data to write.\n @param Offset\n     Offset within the file to write to.\n @param Length\n     Length of data to write.\n @param WriteToEndOfFile\n     When TRUE the file system must write to the current end of file. In this case the Offset\n     parameter will contain the value -1.\n @param ConstrainedIo\n     When TRUE the file system must not extend the file (i.e. change the file size).\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes written.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous\n     operation."]
    pub Write: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Buffer: PVOID,
            Offset: UINT64,
            Length: ULONG,
            WriteToEndOfFile: BOOLEAN,
            ConstrainedIo: BOOLEAN,
            PBytesTransferred: PULONG,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Flush a file or volume.\n\n Note that the FSD will also flush all file/volume caches prior to invoking this operation.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to be flushed. When NULL the whole volume is being flushed.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc. Used when\n     flushing file (not volume).\n @return\n     STATUS_SUCCESS or error code."]
    pub Flush: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Get file or directory information.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to get information for.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub GetFileInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Set file or directory basic information.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to set information for.\n @param FileAttributes\n     File attributes to apply to the file or directory. If the value INVALID_FILE_ATTRIBUTES\n     is sent, the file attributes should not be changed.\n @param CreationTime\n     Creation time to apply to the file or directory. If the value 0 is sent, the creation\n     time should not be changed.\n @param LastAccessTime\n     Last access time to apply to the file or directory. If the value 0 is sent, the last\n     access time should not be changed.\n @param LastWriteTime\n     Last write time to apply to the file or directory. If the value 0 is sent, the last\n     write time should not be changed.\n @param ChangeTime\n     Change time to apply to the file or directory. If the value 0 is sent, the change time\n     should not be changed.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub SetBasicInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileAttributes: UINT32,
            CreationTime: UINT64,
            LastAccessTime: UINT64,
            LastWriteTime: UINT64,
            ChangeTime: UINT64,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Set file/allocation size.\n\n This function is used to change a file's sizes. Windows file systems maintain two kinds\n of sizes: the file size is where the End Of File (EOF) is, and the allocation size is the\n actual size that a file takes up on the \"disk\".\n\n The rules regarding file/allocation size are:\n <ul>\n <li>Allocation size must always be aligned to the allocation unit boundary. The allocation\n unit is the product <code>(UINT64)SectorSize * (UINT64)SectorsPerAllocationUnit</code> from\n the FSP_FSCTL_VOLUME_PARAMS structure. The FSD will always send properly aligned allocation\n sizes when setting the allocation size.</li>\n <li>Allocation size is always greater or equal to the file size.</li>\n <li>A file size of more than the current allocation size will also extend the allocation\n size to the next allocation unit boundary.</li>\n <li>An allocation size of less than the current file size should also truncate the current\n file size.</li>\n </ul>\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to set the file/allocation size for.\n @param NewSize\n     New file/allocation size to apply to the file.\n @param SetAllocationSize\n     If TRUE, then the allocation size is being set. if FALSE, then the file size is being set.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub SetFileSize: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            NewSize: UINT64,
            SetAllocationSize: BOOLEAN,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Determine whether a file or directory can be deleted.\n\n This function tests whether a file or directory can be safely deleted. This function does\n not need to perform access checks, but may performs tasks such as check for empty\n directories, etc.\n\n This function should <b>NEVER</b> delete the file or directory in question. Deletion should\n happen during Cleanup with the FspCleanupDelete flag set.\n\n This function gets called when Win32 API's such as DeleteFile or RemoveDirectory are used.\n It does not get called when a file or directory is opened with FILE_DELETE_ON_CLOSE.\n\n NOTE: If both CanDelete and SetDelete are defined, SetDelete takes precedence. However\n most file systems need only implement the CanDelete operation.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to test for deletion.\n @param FileName\n     The name of the file or directory to test for deletion.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     Cleanup\n     SetDelete"]
    pub CanDelete: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
        ) -> NTSTATUS,
    >,
    #[doc = " Renames a file or directory.\n\n The kernel mode FSD provides certain guarantees prior to posting a rename operation:\n <ul>\n <li>A file cannot be renamed if a file with the same name exists and has open handles.</li>\n <li>A directory cannot be renamed if it or any of its subdirectories contains a file that\n has open handles.</li>\n </ul>\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to be renamed.\n @param FileName\n     The current name of the file or directory to rename.\n @param NewFileName\n     The new name for the file or directory.\n @param ReplaceIfExists\n     Whether to replace a file that already exists at NewFileName.\n @return\n     STATUS_SUCCESS or error code."]
    pub Rename: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            NewFileName: PWSTR,
            ReplaceIfExists: BOOLEAN,
        ) -> NTSTATUS,
    >,
    #[doc = " Get file or directory security descriptor.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to get the security descriptor for.\n @param SecurityDescriptor\n     Pointer to a buffer that will receive the file security descriptor on successful return\n     from this call. May be NULL.\n @param PSecurityDescriptorSize [in,out]\n     Pointer to the security descriptor buffer size. On input it contains the size of the\n     security descriptor buffer. On output it will contain the actual size of the security\n     descriptor copied into the security descriptor buffer. Cannot be NULL.\n @return\n     STATUS_SUCCESS or error code."]
    pub GetSecurity: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            PSecurityDescriptorSize: *mut SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Set file or directory security descriptor.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to set the security descriptor for.\n @param SecurityInformation\n     Describes what parts of the file or directory security descriptor should\n     be modified.\n @param ModificationDescriptor\n     Describes the modifications to apply to the file or directory security descriptor.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     FspSetSecurityDescriptor\n     FspDeleteSecurityDescriptor"]
    pub SetSecurity: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            SecurityInformation: SECURITY_INFORMATION,
            ModificationDescriptor: PSECURITY_DESCRIPTOR,
        ) -> NTSTATUS,
    >,
    #[doc = " Read a directory.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the directory to be read.\n @param Pattern\n     The pattern to match against files in this directory. Can be NULL. The file system\n     can choose to ignore this parameter as the FSD will always perform its own pattern\n     matching on the returned results.\n @param Marker\n     A file name that marks where in the directory to start reading. Files with names\n     that are greater than (not equal to) this marker (in the directory order determined\n     by the file system) should be returned. Can be NULL.\n @param Buffer\n     Pointer to a buffer that will receive the results of the read operation.\n @param Length\n     Length of data to read.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes read.\n @return\n     STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous\n     operation.\n @see\n     FspFileSystemAddDirInfo"]
    pub ReadDirectory: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Pattern: PWSTR,
            Marker: PWSTR,
            Buffer: PVOID,
            Length: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Resolve reparse points.\n\n Reparse points are a general mechanism for attaching special behavior to files.\n A file or directory can contain a reparse point. A reparse point is data that has\n special meaning to the file system, Windows or user applications. For example, NTFS\n and Windows use reparse points to implement symbolic links. As another example,\n a particular file system may use reparse points to emulate UNIX FIFO's.\n\n This function is expected to resolve as many reparse points as possible. If a reparse\n point is encountered that is not understood by the file system further reparse point\n resolution should stop; the reparse point data should be returned to the FSD with status\n STATUS_REPARSE/reparse-tag. If a reparse point (symbolic link) is encountered that is\n understood by the file system but points outside it, the reparse point should be\n resolved, but further reparse point resolution should stop; the resolved file name\n should be returned to the FSD with status STATUS_REPARSE/IO_REPARSE.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileName\n     The name of the file or directory to have its reparse points resolved.\n @param ReparsePointIndex\n     The index of the first reparse point within FileName.\n @param ResolveLastPathComponent\n     If FALSE, the last path component of FileName should not be resolved, even\n     if it is a reparse point that can be resolved. If TRUE, all path components\n     should be resolved if possible.\n @param PIoStatus\n     Pointer to storage that will receive the status to return to the FSD. When\n     this function succeeds it must set PIoStatus->Status to STATUS_REPARSE and\n     PIoStatus->Information to either IO_REPARSE or the reparse tag.\n @param Buffer\n     Pointer to a buffer that will receive the resolved file name (IO_REPARSE) or\n     reparse data (reparse tag). If the function returns a file name, it should\n     not be NULL terminated.\n @param PSize [in,out]\n     Pointer to the buffer size. On input it contains the size of the buffer.\n     On output it will contain the actual size of data copied.\n @return\n     STATUS_REPARSE or error code."]
    pub ResolveReparsePoints: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            ReparsePointIndex: UINT32,
            ResolveLastPathComponent: BOOLEAN,
            PIoStatus: PIO_STATUS_BLOCK,
            Buffer: PVOID,
            PSize: PSIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Get reparse point.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the reparse point.\n @param FileName\n     The file name of the reparse point.\n @param Buffer\n     Pointer to a buffer that will receive the results of this operation. If\n     the function returns a symbolic link path, it should not be NULL terminated.\n @param PSize [in,out]\n     Pointer to the buffer size. On input it contains the size of the buffer.\n     On output it will contain the actual size of data copied.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     SetReparsePoint"]
    pub GetReparsePoint: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Buffer: PVOID,
            PSize: PSIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Set reparse point.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the reparse point.\n @param FileName\n     The file name of the reparse point.\n @param Buffer\n     Pointer to a buffer that contains the data for this operation. If this buffer\n     contains a symbolic link path, it should not be assumed to be NULL terminated.\n @param Size\n     Size of data to write.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     GetReparsePoint"]
    pub SetReparsePoint: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Buffer: PVOID,
            Size: SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Delete reparse point.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the reparse point.\n @param FileName\n     The file name of the reparse point.\n @param Buffer\n     Pointer to a buffer that contains the data for this operation.\n @param Size\n     Size of data to write.\n @return\n     STATUS_SUCCESS or error code."]
    pub DeleteReparsePoint: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Buffer: PVOID,
            Size: SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Get named streams information.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to get stream information for.\n @param Buffer\n     Pointer to a buffer that will receive the stream information.\n @param Length\n     Length of buffer.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes stored.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     FspFileSystemAddStreamInfo"]
    pub GetStreamInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Buffer: PVOID,
            Length: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Get directory information for a single file or directory within a parent directory.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the parent directory.\n @param FileName\n     The name of the file or directory to get information for. This name is relative\n     to the parent directory and is a single path component.\n @param DirInfo [out]\n     Pointer to a structure that will receive the directory information on successful\n     return from this call. This information includes the file name, but also file\n     attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub GetDirInfoByName: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            DirInfo: *mut FSP_FSCTL_DIR_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Process control code.\n\n This function is called when a program uses the DeviceIoControl API.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to be controled.\n @param ControlCode\n     The control code for the operation. This code must have a DeviceType with bit\n     0x8000 set and must have a TransferType of METHOD_BUFFERED.\n @param InputBuffer\n     Pointer to a buffer that contains the input data.\n @param InputBufferLength\n     Input data length.\n @param OutputBuffer\n     Pointer to a buffer that will receive the output data.\n @param OutputBufferLength\n     Output data length.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes transferred.\n @return\n     STATUS_SUCCESS or error code."]
    pub Control: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            ControlCode: UINT32,
            InputBuffer: PVOID,
            InputBufferLength: ULONG,
            OutputBuffer: PVOID,
            OutputBufferLength: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Set the file delete flag.\n\n This function sets a flag to indicates whether the FSD file should delete a file\n when it is closed. This function does not need to perform access checks, but may\n performs tasks such as check for empty directories, etc.\n\n This function should <b>NEVER</b> delete the file or directory in question. Deletion should\n happen during Cleanup with the FspCleanupDelete flag set.\n\n This function gets called when Win32 API's such as DeleteFile or RemoveDirectory are used.\n It does not get called when a file or directory is opened with FILE_DELETE_ON_CLOSE.\n\n NOTE: If both CanDelete and SetDelete are defined, SetDelete takes precedence. However\n most file systems need only implement the CanDelete operation.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file or directory to set the delete flag for.\n @param FileName\n     The name of the file or directory to set the delete flag for.\n @param DeleteFile\n     If set to TRUE the FSD indicates that the file will be deleted on Cleanup; otherwise\n     it will not be deleted. It is legal to receive multiple SetDelete calls for the same\n     file with different DeleteFile parameters.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     Cleanup\n     CanDelete"]
    pub SetDelete: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            DeleteFileW: BOOLEAN,
        ) -> NTSTATUS,
    >,
    #[doc = " Create new file or directory.\n\n This function works like Create, except that it also accepts an extra buffer that\n may contain extended attributes or a reparse point.\n\n NOTE: If both Create and CreateEx are defined, CreateEx takes precedence.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileName\n     The name of the file or directory to be created.\n @param CreateOptions\n     Create options for this request. This parameter has the same meaning as the\n     CreateOptions parameter of the NtCreateFile API. User mode file systems should typically\n     only be concerned with the flag FILE_DIRECTORY_FILE, which is an instruction to create a\n     directory rather than a file. Some file systems may also want to pay attention to the\n     FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH flags, although these are\n     typically handled by the FSD component.\n @param GrantedAccess\n     Determines the specific access rights that have been granted for this request. Upon\n     receiving this call all access checks have been performed and the user mode file system\n     need not perform any additional checks. However this parameter may be useful to a user\n     mode file system; for example the WinFsp-FUSE layer uses this parameter to determine\n     which flags to use in its POSIX open() call.\n @param FileAttributes\n     File attributes to apply to the newly created file or directory.\n @param SecurityDescriptor\n     Security descriptor to apply to the newly created file or directory. This security\n     descriptor will always be in self-relative format. Its length can be retrieved using the\n     Windows GetSecurityDescriptorLength API. Will be NULL for named streams.\n @param AllocationSize\n     Allocation size for the newly created file.\n @param ExtraBuffer\n     Extended attributes or reparse point buffer.\n @param ExtraLength\n     Extended attributes or reparse point buffer length.\n @param ExtraBufferIsReparsePoint\n     FALSE: extra buffer is extended attributes; TRUE: extra buffer is reparse point.\n @param PFileContext [out]\n     Pointer that will receive the file context on successful return from this call.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub CreateEx: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            CreateOptions: UINT32,
            GrantedAccess: UINT32,
            FileAttributes: UINT32,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            AllocationSize: UINT64,
            ExtraBuffer: PVOID,
            ExtraLength: ULONG,
            ExtraBufferIsReparsePoint: BOOLEAN,
            PFileContext: *mut PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Overwrite a file.\n\n This function works like Overwrite, except that it also accepts EA (extended attributes).\n\n NOTE: If both Overwrite and OverwriteEx are defined, OverwriteEx takes precedence.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to overwrite.\n @param FileAttributes\n     File attributes to apply to the overwritten file.\n @param ReplaceFileAttributes\n     When TRUE the existing file attributes should be replaced with the new ones.\n     When FALSE the existing file attributes should be merged (or'ed) with the new ones.\n @param AllocationSize\n     Allocation size for the overwritten file.\n @param Ea\n     Extended attributes buffer.\n @param EaLength\n     Extended attributes buffer length.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code."]
    pub OverwriteEx: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileAttributes: UINT32,
            ReplaceFileAttributes: BOOLEAN,
            AllocationSize: UINT64,
            Ea: PFILE_FULL_EA_INFORMATION,
            EaLength: ULONG,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Get extended attributes.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to get extended attributes for.\n @param Ea\n     Extended attributes buffer.\n @param EaLength\n     Extended attributes buffer length.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes transferred.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     SetEa\n     FspFileSystemAddEa"]
    pub GetEa: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Ea: PFILE_FULL_EA_INFORMATION,
            EaLength: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Set extended attributes.\n\n @param FileSystem\n     The file system on which this request is posted.\n @param FileContext\n     The file context of the file to set extended attributes for.\n @param Ea\n     Extended attributes buffer.\n @param EaLength\n     Extended attributes buffer length.\n @param FileInfo [out]\n     Pointer to a structure that will receive the file information on successful return\n     from this call. This information includes file attributes, file times, etc.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     GetEa"]
    pub SetEa: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Ea: PFILE_FULL_EA_INFORMATION,
            EaLength: ULONG,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    pub Obsolete0: ::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>,
    pub Reserved: [::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>; 32usize],
}
#[test]
fn bindgen_test_layout__FSP_FILE_SYSTEM_INTERFACE() {
    const UNINIT: ::std::mem::MaybeUninit<_FSP_FILE_SYSTEM_INTERFACE> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FSP_FILE_SYSTEM_INTERFACE>(),
        512usize,
        concat!("Size of: ", stringify!(_FSP_FILE_SYSTEM_INTERFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_FILE_SYSTEM_INTERFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_FILE_SYSTEM_INTERFACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetVolumeInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetVolumeInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetVolumeLabelW) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetVolumeLabelW)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSecurityByName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetSecurityByName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Create) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Create)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Open) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Overwrite) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Overwrite)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Cleanup) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Cleanup)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Close) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Close)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Read) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Read)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Write) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Write)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Flush) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Flush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetFileInfo) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetFileInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetBasicInfo) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetBasicInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetFileSize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetFileSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CanDelete) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(CanDelete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rename) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Rename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetSecurity) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetSecurity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetSecurity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ReadDirectory) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(ReadDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ResolveReparsePoints) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(ResolveReparsePoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetReparsePoint) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetReparsePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetReparsePoint) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetReparsePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DeleteReparsePoint) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(DeleteReparsePoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetStreamInfo) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetStreamInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetDirInfoByName) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetDirInfoByName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Control) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetDelete) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetDelete)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CreateEx) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(CreateEx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OverwriteEx) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(OverwriteEx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).GetEa) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetEa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetEa)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Obsolete0) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Obsolete0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Reserved)
        )
    );
}
#[doc = " @class FSP_FILE_SYSTEM\n File system interface.\n\n The operations in this interface must be implemented by the user mode\n file system. Not all operations need be implemented. For example,\n a user mode file system that does not wish to support reparse points,\n need not implement the reparse point operations.\n\n Most of the operations accept a FileContext parameter. This parameter\n has different meanings depending on the value of the FSP_FSCTL_VOLUME_PARAMS\n flags UmFileContextIsUserContext2 and UmFileContextIsFullContext.\n\n There are three cases to consider:\n <ul>\n <li>When both of these flags are unset (default), the FileContext parameter\n represents the file node. The file node is a void pointer (or an integer\n that can fit in a pointer) that is used to uniquely identify an open file.\n Opening the same file name should always yield the same file node value\n for as long as the file with that name remains open anywhere in the system.\n </li>\n <li>When the UmFileContextIsUserContext2 is set, the FileContext parameter\n represents the file descriptor. The file descriptor is a void pointer (or\n an integer that can fit in a pointer) that is used to identify an open\n instance of a file. Opening the same file name may yield a different file\n descriptor.\n </li>\n <li>When the UmFileContextIsFullContext is set, the FileContext parameter\n is a pointer to a FSP_FSCTL_TRANSACT_FULL_CONTEXT. This allows a user mode\n file system to access the low-level UserContext and UserContext2 values.\n The UserContext is used to store the file node and the UserContext2 is\n used to store the file descriptor for an open file.\n </li>\n </ul>"]
pub type FSP_FILE_SYSTEM_INTERFACE = _FSP_FILE_SYSTEM_INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSP_FILE_SYSTEM {
    pub Version: UINT16,
    pub UserContext: PVOID,
    pub VolumeName: [WCHAR; 256usize],
    pub VolumeHandle: HANDLE,
    pub EnterOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
    pub LeaveOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
    pub Operations: [FSP_FILE_SYSTEM_OPERATION; 22usize],
    pub Interface: *const FSP_FILE_SYSTEM_INTERFACE,
    pub DispatcherThread: HANDLE,
    pub DispatcherThreadCount: ULONG,
    pub DispatcherResult: NTSTATUS,
    pub MountPoint: PWSTR,
    pub MountHandle: HANDLE,
    pub DebugLog: UINT32,
    pub OpGuardStrategy: FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY,
    pub OpGuardLock: SRWLOCK,
    pub UmFileContextIsUserContext2: BOOLEAN,
    pub UmFileContextIsFullContext: BOOLEAN,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__FSP_FILE_SYSTEM() {
    const UNINIT: ::std::mem::MaybeUninit<_FSP_FILE_SYSTEM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FSP_FILE_SYSTEM>(),
        792usize,
        concat!("Size of: ", stringify!(_FSP_FILE_SYSTEM))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_FILE_SYSTEM>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_FILE_SYSTEM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).VolumeHandle) as usize - ptr as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(VolumeHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).EnterOperation) as usize - ptr as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(EnterOperation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).LeaveOperation) as usize - ptr as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(LeaveOperation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Operations) as usize - ptr as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(Operations)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Interface) as usize - ptr as usize },
        728usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(Interface)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DispatcherThread) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DispatcherThread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DispatcherThreadCount) as usize - ptr as usize },
        744usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DispatcherThreadCount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DispatcherResult) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DispatcherResult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MountPoint) as usize - ptr as usize },
        752usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(MountPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MountHandle) as usize - ptr as usize },
        760usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(MountHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).DebugLog) as usize - ptr as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DebugLog)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpGuardStrategy) as usize - ptr as usize },
        772usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(OpGuardStrategy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OpGuardLock) as usize - ptr as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(OpGuardLock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UmFileContextIsUserContext2) as usize - ptr as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(UmFileContextIsUserContext2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UmFileContextIsFullContext) as usize - ptr as usize },
        785usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(UmFileContextIsFullContext)
        )
    );
}
impl Default for _FSP_FILE_SYSTEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _FSP_FILE_SYSTEM {
    #[inline]
    pub fn UmNoReparsePointsDirCheck(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UmNoReparsePointsDirCheck(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmReservedFlags(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_UmReservedFlags(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UmNoReparsePointsDirCheck: UINT16,
        UmReservedFlags: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UmNoReparsePointsDirCheck: u16 =
                unsafe { ::std::mem::transmute(UmNoReparsePointsDirCheck) };
            UmNoReparsePointsDirCheck as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let UmReservedFlags: u16 = unsafe { ::std::mem::transmute(UmReservedFlags) };
            UmReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSP_FILE_SYSTEM_OPERATION_CONTEXT {
    pub Request: *mut FSP_FSCTL_TRANSACT_REQ,
    pub Response: *mut FSP_FSCTL_TRANSACT_RSP,
}
#[test]
fn bindgen_test_layout__FSP_FILE_SYSTEM_OPERATION_CONTEXT() {
    const UNINIT: ::std::mem::MaybeUninit<_FSP_FILE_SYSTEM_OPERATION_CONTEXT> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FSP_FILE_SYSTEM_OPERATION_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_FILE_SYSTEM_OPERATION_CONTEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Request) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT),
            "::",
            stringify!(Request)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Response) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT),
            "::",
            stringify!(Response)
        )
    );
}
impl Default for _FSP_FILE_SYSTEM_OPERATION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FSP_FILE_SYSTEM_OPERATION_CONTEXT = _FSP_FILE_SYSTEM_OPERATION_CONTEXT;
extern "C" {
    #[doc = " Check whether creating a file system object is possible.\n\n @param DevicePath\n     The name of the control device for this file system. This must be either\n     FSP_FSCTL_DISK_DEVICE_NAME or FSP_FSCTL_NET_DEVICE_NAME.\n @param MountPoint\n     The mount point for the new file system. A value of NULL means that the file system should\n     use the next available drive letter counting downwards from Z: as its mount point.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemPreflight(DevicePath: PWSTR, MountPoint: PWSTR) -> NTSTATUS;
}
extern "C" {
    #[doc = " Create a file system object.\n\n @param DevicePath\n     The name of the control device for this file system. This must be either\n     FSP_FSCTL_DISK_DEVICE_NAME or FSP_FSCTL_NET_DEVICE_NAME.\n @param VolumeParams\n     Volume parameters for the newly created file system.\n @param Interface\n     A pointer to the actual operations that actually implement this user mode file system.\n @param PFileSystem [out]\n     Pointer that will receive the file system object created on successful return from this\n     call.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemCreate(
        DevicePath: PWSTR,
        VolumeParams: *const FSP_FSCTL_VOLUME_PARAMS,
        Interface: *const FSP_FILE_SYSTEM_INTERFACE,
        PFileSystem: *mut *mut FSP_FILE_SYSTEM,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Delete a file system object.\n\n @param FileSystem\n     The file system object."]
    pub fn FspFileSystemDelete(FileSystem: *mut FSP_FILE_SYSTEM);
}
extern "C" {
    #[doc = " Set the mount point for a file system.\n\n This function supports drive letters (X:) or directories as mount points:\n <ul>\n <li>Drive letters: Refer to the documentation of the DefineDosDevice Windows API\n to better understand how they are created.</li>\n <li>Directories: They can be used as mount points for disk based file systems. They cannot\n be used for network file systems. This is a limitation that Windows imposes on junctions.</li>\n </ul>\n\n @param FileSystem\n     The file system object.\n @param MountPoint\n     The mount point for the new file system. A value of NULL means that the file system should\n     use the next available drive letter counting downwards from Z: as its mount point.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemSetMountPoint(
        FileSystem: *mut FSP_FILE_SYSTEM,
        MountPoint: PWSTR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemSetMountPointEx(
        FileSystem: *mut FSP_FILE_SYSTEM,
        MountPoint: PWSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Remove the mount point for a file system.\n\n @param FileSystem\n     The file system object."]
    pub fn FspFileSystemRemoveMountPoint(FileSystem: *mut FSP_FILE_SYSTEM);
}
extern "C" {
    #[doc = " Start the file system dispatcher.\n\n The file system dispatcher is used to dispatch operations posted by the FSD to the user mode\n file system. Once this call starts executing the user mode file system will start receiving\n file system requests from the kernel.\n\n @param FileSystem\n     The file system object.\n @param ThreadCount\n     The number of threads for the file system dispatcher. A value of 0 will create a default\n     number of threads and should be chosen in most cases.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemStartDispatcher(
        FileSystem: *mut FSP_FILE_SYSTEM,
        ThreadCount: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Stop the file system dispatcher.\n\n @param FileSystem\n     The file system object."]
    pub fn FspFileSystemStopDispatcher(FileSystem: *mut FSP_FILE_SYSTEM);
}
extern "C" {
    #[doc = " Send a response to the FSD.\n\n This call is not required when the user mode file system performs synchronous processing of\n requests. It is possible however for the following FSP_FILE_SYSTEM_INTERFACE operations to be\n processed asynchronously:\n <ul>\n <li>Read</li>\n <li>Write</li>\n <li>ReadDirectory</li>\n </ul>\n\n These operations are allowed to return STATUS_PENDING to postpone sending a response to the FSD.\n At a later time the file system can use FspFileSystemSendResponse to send the response.\n\n @param FileSystem\n     The file system object.\n @param Response\n     The response buffer."]
    pub fn FspFileSystemSendResponse(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    );
}
extern "C" {
    #[doc = " Begin notifying Windows that the file system has file changes.\n\n A file system that wishes to notify Windows about file changes must\n first issue an FspFileSystemBegin call, followed by 0 or more\n FspFileSystemNotify calls, followed by an FspFileSystemNotifyEnd call.\n\n This operation blocks concurrent file rename operations. File rename\n operations may interfere with file notification, because a file being\n notified may also be concurrently renamed. After all file change\n notifications have been issued, you must make sure to call\n FspFileSystemNotifyEnd to allow file rename operations to proceed.\n\n @param FileSystem\n     The file system object.\n @return\n     STATUS_SUCCESS or error code. The error code STATUS_CANT_WAIT means that\n     a file rename operation is currently in progress and the operation must be\n     retried at a later time."]
    pub fn FspFileSystemNotifyBegin(FileSystem: *mut FSP_FILE_SYSTEM, Timeout: ULONG) -> NTSTATUS;
}
extern "C" {
    #[doc = " End notifying Windows that the file system has file changes.\n\n A file system that wishes to notify Windows about file changes must\n first issue an FspFileSystemBegin call, followed by 0 or more\n FspFileSystemNotify calls, followed by an FspFileSystemNotifyEnd call.\n\n This operation allows any blocked file rename operations to proceed.\n\n @param FileSystem\n     The file system object.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemNotifyEnd(FileSystem: *mut FSP_FILE_SYSTEM) -> NTSTATUS;
}
extern "C" {
    #[doc = " Notify Windows that the file system has file changes.\n\n A file system that wishes to notify Windows about file changes must\n first issue an FspFileSystemBegin call, followed by 0 or more\n FspFileSystemNotify calls, followed by an FspFileSystemNotifyEnd call.\n\n Note that FspFileSystemNotify requires file names to be normalized. A\n normalized file name is one that contains the correct case of all characters\n in the file name.\n\n For case-sensitive file systems all file names are normalized by definition.\n For case-insensitive file systems that implement file name normalization,\n a normalized file name is the one that the file system specifies in the\n response to Create or Open (see also FspFileSystemGetOpenFileInfo). For\n case-insensitive file systems that do not implement file name normalization\n a normalized file name is the upper case version of the file name used\n to open the file.\n\n @param FileSystem\n     The file system object.\n @param NotifyInfo\n     Buffer containing information about file changes.\n @param Size\n     Size of buffer.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemNotify(
        FileSystem: *mut FSP_FILE_SYSTEM,
        NotifyInfo: *mut FSP_FSCTL_NOTIFY_INFO,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Get the current operation context.\n\n This function may be used only when servicing one of the FSP_FILE_SYSTEM_INTERFACE operations.\n The current operation context is stored in thread local storage. It allows access to the\n Request and Response associated with this operation.\n\n @return\n     The current operation context."]
    pub fn FspFileSystemGetOperationContext() -> *mut FSP_FILE_SYSTEM_OPERATION_CONTEXT;
}
extern "C" {
    pub fn FspFileSystemMountPointF(FileSystem: *mut FSP_FILE_SYSTEM) -> PWSTR;
}
extern "C" {
    pub fn FspFileSystemEnterOperationF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemLeaveOperationF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemSetOperationGuardF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        EnterOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
        LeaveOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
    );
}
extern "C" {
    pub fn FspFileSystemSetOperationGuardStrategyF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        GuardStrategy: FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY,
    );
}
extern "C" {
    pub fn FspFileSystemSetOperationF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Index: ULONG,
        Operation: FSP_FILE_SYSTEM_OPERATION,
    );
}
extern "C" {
    pub fn FspFileSystemGetDispatcherResultF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        PDispatcherResult: *mut NTSTATUS,
    );
}
extern "C" {
    pub fn FspFileSystemSetDispatcherResultF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        DispatcherResult: NTSTATUS,
    );
}
extern "C" {
    pub fn FspFileSystemSetDebugLogF(FileSystem: *mut FSP_FILE_SYSTEM, DebugLog: UINT32);
}
extern "C" {
    pub fn FspFileSystemIsOperationCaseSensitiveF() -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemOperationProcessIdF() -> UINT32;
}
extern "C" {
    pub fn FspFileSystemOpEnter(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpLeave(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpCreate(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpOverwrite(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpCleanup(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpClose(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpRead(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpWrite(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryEa(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetEa(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpFlushBuffers(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryVolumeInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetVolumeInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryDirectory(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpFileSystemControl(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpDeviceControl(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQuerySecurity(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetSecurity(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryStreamInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Add directory information to a buffer.\n\n This is a helper for implementing the ReadDirectory operation.\n\n @param DirInfo\n     The directory information to add. A value of NULL acts as an EOF marker for a ReadDirectory\n     operation.\n @param Buffer\n     Pointer to a buffer that will receive the results of the read operation. This should contain\n     the same value passed to the ReadDirectory Buffer parameter.\n @param Length\n     Length of data to read. This should contain the same value passed to the ReadDirectory\n     Length parameter.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes read. This should\n     contain the same value passed to the ReadDirectory PBytesTransferred parameter.\n     FspFileSystemAddDirInfo uses the value pointed by this parameter to track how much of the\n     buffer has been used so far.\n @return\n     TRUE if the directory information was added, FALSE if there was not enough space to add it.\n @see\n     ReadDirectory"]
    pub fn FspFileSystemAddDirInfo(
        DirInfo: *mut FSP_FSCTL_DIR_INFO,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Find reparse point in file name.\n\n Given a file name this function returns an index to the first path component that is a reparse\n point. The function will call the supplied GetReparsePointByName function for every path\n component until it finds a reparse point or the whole path is processed.\n\n This is a helper for implementing the GetSecurityByName operation in file systems\n that support reparse points.\n\n @param FileSystem\n     The file system object.\n @param GetReparsePointByName\n     Pointer to function that can retrieve reparse point information by name. The\n     FspFileSystemFindReparsePoint will call this function with the Buffer and PSize\n     arguments set to NULL. The function should return STATUS_SUCCESS if the passed\n     FileName is a reparse point or STATUS_NOT_A_REPARSE_POINT (or other error code)\n     otherwise.\n @param Context\n     User context to supply to GetReparsePointByName.\n @param FileName\n     The name of the file or directory.\n @param PReparsePointIndex\n     Pointer to a memory location that will receive the index of the first reparse point\n     within FileName. A value is only placed in this memory location if the function returns\n     TRUE. May be NULL.\n @return\n     TRUE if a reparse point was found, FALSE otherwise.\n @see\n     GetSecurityByName"]
    pub fn FspFileSystemFindReparsePoint(
        FileSystem: *mut FSP_FILE_SYSTEM,
        GetReparsePointByName: ::std::option::Option<
            unsafe extern "C" fn(
                FileSystem: *mut FSP_FILE_SYSTEM,
                Context: PVOID,
                FileName: PWSTR,
                IsDirectory: BOOLEAN,
                Buffer: PVOID,
                PSize: PSIZE_T,
            ) -> NTSTATUS,
        >,
        Context: PVOID,
        FileName: PWSTR,
        PReparsePointIndex: PUINT32,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Resolve reparse points.\n\n Given a file name (and an index where to start resolving) this function will attempt to\n resolve as many reparse points as possible. The function will call the supplied\n GetReparsePointByName function for every path component until it resolves the reparse points\n or the whole path is processed.\n\n This is a helper for implementing the ResolveReparsePoints operation in file systems\n that support reparse points.\n\n @param FileSystem\n     The file system object.\n @param GetReparsePointByName\n     Pointer to function that can retrieve reparse point information by name. The function\n     should return STATUS_SUCCESS if the passed FileName is a reparse point or\n     STATUS_NOT_A_REPARSE_POINT (or other error code) otherwise.\n @param Context\n     User context to supply to GetReparsePointByName.\n @param FileName\n     The name of the file or directory to have its reparse points resolved.\n @param ReparsePointIndex\n     The index of the first reparse point within FileName.\n @param ResolveLastPathComponent\n     If FALSE, the last path component of FileName should not be resolved, even\n     if it is a reparse point that can be resolved. If TRUE, all path components\n     should be resolved if possible.\n @param PIoStatus\n     Pointer to storage that will receive the status to return to the FSD. When\n     this function succeeds it must set PIoStatus->Status to STATUS_REPARSE and\n     PIoStatus->Information to either IO_REPARSE or the reparse tag.\n @param Buffer\n     Pointer to a buffer that will receive the resolved file name (IO_REPARSE) or\n     reparse data (reparse tag). If the function returns a file name, it should\n     not be NULL terminated.\n @param PSize [in,out]\n     Pointer to the buffer size. On input it contains the size of the buffer.\n     On output it will contain the actual size of data copied.\n @return\n     STATUS_REPARSE or error code.\n @see\n     ResolveReparsePoints"]
    pub fn FspFileSystemResolveReparsePoints(
        FileSystem: *mut FSP_FILE_SYSTEM,
        GetReparsePointByName: ::std::option::Option<
            unsafe extern "C" fn(
                FileSystem: *mut FSP_FILE_SYSTEM,
                Context: PVOID,
                FileName: PWSTR,
                IsDirectory: BOOLEAN,
                Buffer: PVOID,
                PSize: PSIZE_T,
            ) -> NTSTATUS,
        >,
        Context: PVOID,
        FileName: PWSTR,
        ReparsePointIndex: UINT32,
        ResolveLastPathComponent: BOOLEAN,
        PIoStatus: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        PSize: PSIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Test whether reparse data can be replaced.\n\n This is a helper for implementing the SetReparsePoint/DeleteReparsePoint operation\n in file systems that support reparse points.\n\n @param CurrentReparseData\n     Pointer to the current reparse data.\n @param CurrentReparseDataSize\n     Pointer to the current reparse data size.\n @param ReplaceReparseData\n     Pointer to the replacement reparse data.\n @param ReplaceReparseDataSize\n     Pointer to the replacement reparse data size.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     SetReparsePoint\n     DeleteReparsePoint"]
    pub fn FspFileSystemCanReplaceReparsePoint(
        CurrentReparseData: PVOID,
        CurrentReparseDataSize: SIZE_T,
        ReplaceReparseData: PVOID,
        ReplaceReparseDataSize: SIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Add named stream information to a buffer.\n\n This is a helper for implementing the GetStreamInfo operation.\n\n @param StreamInfo\n     The stream information to add. A value of NULL acts as an EOF marker for a GetStreamInfo\n     operation.\n @param Buffer\n     Pointer to a buffer that will receive the stream information. This should contain\n     the same value passed to the GetStreamInfo Buffer parameter.\n @param Length\n     Length of buffer. This should contain the same value passed to the GetStreamInfo\n     Length parameter.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes stored. This should\n     contain the same value passed to the GetStreamInfo PBytesTransferred parameter.\n @return\n     TRUE if the stream information was added, FALSE if there was not enough space to add it.\n @see\n     GetStreamInfo"]
    pub fn FspFileSystemAddStreamInfo(
        StreamInfo: *mut FSP_FSCTL_STREAM_INFO,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Enumerate extended attributes in a buffer.\n\n This is a helper for implementing the CreateEx and SetEa operations in file systems\n that support extended attributes.\n\n @param FileSystem\n     The file system object.\n @param EnumerateEa\n     Pointer to function that receives a single extended attribute. The function\n     should return STATUS_SUCCESS or an error code if unsuccessful.\n @param Context\n     User context to supply to EnumEa.\n @param Ea\n     Extended attributes buffer.\n @param EaLength\n     Extended attributes buffer length.\n @return\n     STATUS_SUCCESS or error code from EnumerateEa."]
    pub fn FspFileSystemEnumerateEa(
        FileSystem: *mut FSP_FILE_SYSTEM,
        EnumerateEa: ::std::option::Option<
            unsafe extern "C" fn(
                FileSystem: *mut FSP_FILE_SYSTEM,
                Context: PVOID,
                SingleEa: PFILE_FULL_EA_INFORMATION,
            ) -> NTSTATUS,
        >,
        Context: PVOID,
        Ea: PFILE_FULL_EA_INFORMATION,
        EaLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Add extended attribute to a buffer.\n\n This is a helper for implementing the GetEa operation.\n\n @param SingleEa\n     The extended attribute to add. A value of NULL acts as an EOF marker for a GetEa\n     operation.\n @param Ea\n     Pointer to a buffer that will receive the extended attribute. This should contain\n     the same value passed to the GetEa Ea parameter.\n @param EaLength\n     Length of buffer. This should contain the same value passed to the GetEa\n     EaLength parameter.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes stored. This should\n     contain the same value passed to the GetEa PBytesTransferred parameter.\n @return\n     TRUE if the extended attribute was added, FALSE if there was not enough space to add it.\n @see\n     GetEa"]
    pub fn FspFileSystemAddEa(
        SingleEa: PFILE_FULL_EA_INFORMATION,
        Ea: PFILE_FULL_EA_INFORMATION,
        EaLength: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Add notify information to a buffer.\n\n This is a helper for filling a buffer to use with FspFileSystemNotify.\n\n @param NotifyInfo\n     The notify information to add.\n @param Buffer\n     Pointer to a buffer that will receive the notify information.\n @param Length\n     Length of buffer.\n @param PBytesTransferred [out]\n     Pointer to a memory location that will receive the actual number of bytes stored. This should\n     be initialized to 0 prior to the first call to FspFileSystemAddNotifyInfo for a particular\n     buffer.\n @return\n     TRUE if the notify information was added, FALSE if there was not enough space to add it.\n @see\n     FspFileSystemNotify"]
    pub fn FspFileSystemAddNotifyInfo(
        NotifyInfo: *mut FSP_FSCTL_NOTIFY_INFO,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemAcquireDirectoryBufferEx(
        PDirBuffer: *mut PVOID,
        Reset: BOOLEAN,
        CapacityHint: ULONG,
        PResult: PNTSTATUS,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemAcquireDirectoryBuffer(
        PDirBuffer: *mut PVOID,
        Reset: BOOLEAN,
        PResult: PNTSTATUS,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemFillDirectoryBuffer(
        PDirBuffer: *mut PVOID,
        DirInfo: *mut FSP_FSCTL_DIR_INFO,
        PResult: PNTSTATUS,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemReleaseDirectoryBuffer(PDirBuffer: *mut PVOID);
}
extern "C" {
    pub fn FspFileSystemReadDirectoryBuffer(
        PDirBuffer: *mut PVOID,
        Marker: PWSTR,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    );
}
extern "C" {
    pub fn FspFileSystemDeleteDirectoryBuffer(PDirBuffer: *mut PVOID);
}
extern "C" {
    pub fn FspGetFileGenericMapping() -> PGENERIC_MAPPING;
}
extern "C" {
    pub fn FspAccessCheckEx(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        CheckParentOrMain: BOOLEAN,
        AllowTraverseCheck: BOOLEAN,
        DesiredAccess: UINT32,
        PGrantedAccess: PUINT32,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspCreateSecurityDescriptor(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Modify security descriptor.\n\n This is a helper for implementing the SetSecurity operation.\n\n @param InputDescriptor\n     The input security descriptor to be modified.\n @param SecurityInformation\n     Describes what parts of the InputDescriptor should be modified. This should contain\n     the same value passed to the SetSecurity SecurityInformation parameter.\n @param ModificationDescriptor\n     Describes the modifications to apply to the InputDescriptor. This should contain\n     the same value passed to the SetSecurity ModificationDescriptor parameter.\n @param PSecurityDescriptor [out]\n     Pointer to a memory location that will receive the resulting security descriptor.\n     This security descriptor can be later freed using FspDeleteSecurityDescriptor.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     SetSecurity\n     FspDeleteSecurityDescriptor"]
    pub fn FspSetSecurityDescriptor(
        InputDescriptor: PSECURITY_DESCRIPTOR,
        SecurityInformation: SECURITY_INFORMATION,
        ModificationDescriptor: PSECURITY_DESCRIPTOR,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Delete security descriptor.\n\n This is a helper for implementing the SetSecurity operation.\n\n @param SecurityDescriptor\n     The security descriptor to be deleted.\n @param CreateFunc\n     Function used to create the security descriptor. This parameter should be\n     set to FspSetSecurityDescriptor for the public API.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     SetSecurity\n     FspSetSecurityDescriptor"]
    pub fn FspDeleteSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        CreateFunc: ::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>,
    );
}
extern "C" {
    pub fn FspPosixSetUidMap(Uid: *mut UINT32, Sid: *mut PSID, Count: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapUidToSid(Uid: UINT32, PSid: *mut PSID) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapSidToUid(Sid: PSID, PUid: PUINT32) -> NTSTATUS;
}
extern "C" {
    pub fn FspDeleteSid(
        Sid: PSID,
        CreateFunc: ::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>,
    );
}
extern "C" {
    pub fn FspPosixMapPermissionsToSecurityDescriptor(
        Uid: UINT32,
        Gid: UINT32,
        Mode: UINT32,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMergePermissionsToSecurityDescriptor(
        Uid: UINT32,
        Gid: UINT32,
        Mode: UINT32,
        ExistingSecurityDescriptor: PSECURITY_DESCRIPTOR,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapSecurityDescriptorToPermissions(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PUid: PUINT32,
        PGid: PUINT32,
        PMode: PUINT32,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapWindowsToPosixPathEx(
        WindowsPath: PWSTR,
        PPosixPath: *mut *mut ::std::os::raw::c_char,
        Translate: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapPosixToWindowsPathEx(
        PosixPath: *const ::std::os::raw::c_char,
        PWindowsPath: *mut PWSTR,
        Translate: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixDeletePath(Path: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn FspPosixEncodeWindowsPath(WindowsPath: PWSTR, Size: ULONG);
}
extern "C" {
    pub fn FspPosixDecodeWindowsPath(WindowsPath: PWSTR, Size: ULONG);
}
extern "C" {
    pub fn FspPathPrefix(Path: PWSTR, PPrefix: *mut PWSTR, PRemain: *mut PWSTR, Root: PWSTR);
}
extern "C" {
    pub fn FspPathSuffix(Path: PWSTR, PRemain: *mut PWSTR, PSuffix: *mut PWSTR, Root: PWSTR);
}
extern "C" {
    pub fn FspPathCombine(Prefix: PWSTR, Suffix: PWSTR);
}
#[doc = " @group Service Framework\n\n User mode file systems typically are run as Windows services. WinFsp provides an API to make\n the creation of Windows services easier. This API is provided for convenience and is not\n necessary to expose a user mode file system to Windows."]
pub type FSP_SERVICE = _FSP_SERVICE;
pub type FSP_SERVICE_START = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut FSP_SERVICE, arg2: ULONG, arg3: *mut PWSTR) -> NTSTATUS,
>;
pub type FSP_SERVICE_STOP =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut FSP_SERVICE) -> NTSTATUS>;
pub type FSP_SERVICE_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut FSP_SERVICE, arg2: ULONG, arg3: ULONG, arg4: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug)]
pub struct _FSP_SERVICE {
    pub Version: UINT16,
    pub UserContext: PVOID,
    pub OnStart: FSP_SERVICE_START,
    pub OnStop: FSP_SERVICE_STOP,
    pub OnControl: FSP_SERVICE_CONTROL,
    pub AcceptControl: ULONG,
    pub ExitCode: ULONG,
    pub StatusHandle: SERVICE_STATUS_HANDLE,
    pub ServiceStatus: SERVICE_STATUS,
    pub ServiceStatusGuard: CRITICAL_SECTION,
    pub ServiceStopGuard: CRITICAL_SECTION,
    pub AllowConsoleMode: BOOLEAN,
    pub ServiceName: __IncompleteArrayField<WCHAR>,
}
#[test]
fn bindgen_test_layout__FSP_SERVICE() {
    const UNINIT: ::std::mem::MaybeUninit<_FSP_SERVICE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FSP_SERVICE>(),
        176usize,
        concat!("Size of: ", stringify!(_FSP_SERVICE))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_SERVICE>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_SERVICE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(UserContext)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OnStart) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(OnStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OnStop) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(OnStop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).OnControl) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(OnControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AcceptControl) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(AcceptControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ExitCode) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ExitCode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).StatusHandle) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(StatusHandle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServiceStatus) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceStatus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServiceStatusGuard) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceStatusGuard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServiceStopGuard) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceStopGuard)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AllowConsoleMode) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(AllowConsoleMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ServiceName) as usize - ptr as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceName)
        )
    );
}
impl Default for _FSP_SERVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Run a service.\n\n This function wraps calls to FspServiceCreate, FspServiceLoop and FspServiceDelete to create,\n run and delete a service. It is intended to be used from a service's main/wmain function.\n\n This function runs a service with console mode allowed.\n\n @param ServiceName\n     The name of the service.\n @param OnStart\n     Function to call when the service starts.\n @param OnStop\n     Function to call when the service stops.\n @param OnControl\n     Function to call when the service receives a service control code.\n @return\n     Service process exit code."]
    pub fn FspServiceRunEx(
        ServiceName: PWSTR,
        OnStart: FSP_SERVICE_START,
        OnStop: FSP_SERVICE_STOP,
        OnControl: FSP_SERVICE_CONTROL,
        UserContext: PVOID,
    ) -> ULONG;
}
extern "C" {
    #[doc = " Create a service object.\n\n @param ServiceName\n     The name of the service.\n @param OnStart\n     Function to call when the service starts.\n @param OnStop\n     Function to call when the service stops.\n @param OnControl\n     Function to call when the service receives a service control code.\n @param PService [out]\n     Pointer that will receive the service object created on successful return from this\n     call.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspServiceCreate(
        ServiceName: PWSTR,
        OnStart: FSP_SERVICE_START,
        OnStop: FSP_SERVICE_STOP,
        OnControl: FSP_SERVICE_CONTROL,
        PService: *mut *mut FSP_SERVICE,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Delete a service object.\n\n @param Service\n     The service object."]
    pub fn FspServiceDelete(Service: *mut FSP_SERVICE);
}
extern "C" {
    #[doc = " Allow a service to run in console mode.\n\n A service that is run in console mode runs with a console attached and outside the control of\n the Service Control Manager. This is useful for debugging and testing a service during\n development.\n\n User mode file systems that wish to use the WinFsp Launcher functionality must also use this\n call. The WinFsp Launcher is a Windows service that can be configured to launch and manage\n multiple instances of a user mode file system.\n\n @param Service\n     The service object."]
    pub fn FspServiceAllowConsoleMode(Service: *mut FSP_SERVICE);
}
extern "C" {
    #[doc = " Configure the control codes that a service accepts.\n\n This API should be used prior to Start operations.\n\n @param Service\n     The service object.\n @param Control\n     The control codes to accept. Note that the SERVICE_ACCEPT_PAUSE_CONTINUE code is silently\n     ignored."]
    pub fn FspServiceAcceptControl(Service: *mut FSP_SERVICE, Control: ULONG);
}
extern "C" {
    #[doc = " Request additional time from the Service Control Manager.\n\n This API should be used during Start and Stop operations only.\n\n @param Service\n     The service object.\n @param Time\n     Additional time (in milliseconds)."]
    pub fn FspServiceRequestTime(Service: *mut FSP_SERVICE, Time: ULONG);
}
extern "C" {
    #[doc = " Set the service process exit code.\n\n @param Service\n     The service object.\n @param ExitCode\n     Service process exit code."]
    pub fn FspServiceSetExitCode(Service: *mut FSP_SERVICE, ExitCode: ULONG);
}
extern "C" {
    #[doc = " Get the service process exit code.\n\n @param Service\n     The service object.\n @return\n     Service process exit code."]
    pub fn FspServiceGetExitCode(Service: *mut FSP_SERVICE) -> ULONG;
}
extern "C" {
    #[doc = " Run a service main loop.\n\n This function starts and runs a service. It executes the Windows StartServiceCtrlDispatcher API\n to connect the service process to the Service Control Manager. If the Service Control Manager is\n not available (and console mode is allowed) it will enter console mode.\n\n @param Service\n     The service object.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspServiceLoop(Service: *mut FSP_SERVICE) -> NTSTATUS;
}
extern "C" {
    #[doc = " Stops a running service.\n\n Stopping a service usually happens when the Service Control Manager instructs the service to\n stop. In some situations (e.g. fatal errors) the service may wish to stop itself. It can do so\n in a clean manner by calling this function.\n\n @param Service\n     The service object.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspServiceStop(Service: *mut FSP_SERVICE);
}
extern "C" {
    #[doc = " Determine if the current process is running in user interactive mode.\n\n @return\n     TRUE if the process is running in running user interactive mode."]
    pub fn FspServiceIsInteractive() -> BOOLEAN;
}
extern "C" {
    #[doc = " Check if the supplied token is from the service context.\n\n @param Token\n     Token to check. Pass NULL to check the current process token.\n @param PIsLocalSystem\n     Pointer to a boolean that will receive a TRUE value if the token belongs to LocalSystem\n     and FALSE otherwise. May be NULL.\n @return\n     STATUS_SUCCESS if the token is from the service context. STATUS_ACCESS_DENIED if it is not.\n     Other error codes are possible."]
    pub fn FspServiceContextCheck(Token: HANDLE, PIsLocalSystem: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    #[doc = " Log a service message.\n\n This function can be used to log an arbitrary message to the Windows Event Log or to the current\n console if running in user interactive mode.\n\n @param Type\n     One of EVENTLOG_INFORMATION_TYPE, EVENTLOG_WARNING_TYPE, EVENTLOG_ERROR_TYPE.\n @param Format\n     Format specification. This function uses the Windows wsprintf API for formatting. Refer to\n     that API's documentation for details on the format specification."]
    pub fn FspServiceLog(Type: ULONG, Format: PWSTR, ...);
}
extern "C" {
    pub fn FspServiceLogV(Type: ULONG, Format: PWSTR, ap: va_list);
}
extern "C" {
    pub fn FspNtStatusFromWin32(Error: DWORD) -> NTSTATUS;
}
extern "C" {
    pub fn FspWin32FromNtStatus(Status: NTSTATUS) -> DWORD;
}
extern "C" {
    pub fn FspEventLog(Type: ULONG, Format: PWSTR, ...);
}
extern "C" {
    pub fn FspEventLogV(Type: ULONG, Format: PWSTR, ap: va_list);
}
extern "C" {
    pub fn FspDebugLogSetHandle(Handle: HANDLE);
}
extern "C" {
    pub fn FspDebugLog(Format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn FspDebugLogSD(
        Format: *const ::std::os::raw::c_char,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    );
}
extern "C" {
    pub fn FspDebugLogSid(format: *const ::std::os::raw::c_char, Sid: PSID);
}
extern "C" {
    pub fn FspDebugLogFT(Format: *const ::std::os::raw::c_char, FileTime: PFILETIME);
}
extern "C" {
    pub fn FspDebugLogRequest(Request: *mut FSP_FSCTL_TRANSACT_REQ);
}
extern "C" {
    pub fn FspDebugLogResponse(Response: *mut FSP_FSCTL_TRANSACT_RSP);
}
extern "C" {
    pub fn FspCallNamedPipeSecurely(
        PipeName: PWSTR,
        InBuffer: PVOID,
        InBufferSize: ULONG,
        OutBuffer: PVOID,
        OutBufferSize: ULONG,
        PBytesTransferred: PULONG,
        Timeout: ULONG,
        Sid: PSID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspCallNamedPipeSecurelyEx(
        PipeName: PWSTR,
        InBuffer: PVOID,
        InBufferSize: ULONG,
        OutBuffer: PVOID,
        OutBufferSize: ULONG,
        PBytesTransferred: PULONG,
        Timeout: ULONG,
        AllowImpersonation: BOOLEAN,
        Sid: PSID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspVersion(PVersion: PUINT32) -> NTSTATUS;
}
pub const FspLaunchCmdStart: _bindgen_ty_8 = 83;
pub const FspLaunchCmdStartWithSecret: _bindgen_ty_8 = 88;
pub const FspLaunchCmdStop: _bindgen_ty_8 = 84;
pub const FspLaunchCmdGetInfo: _bindgen_ty_8 = 73;
pub const FspLaunchCmdGetNameList: _bindgen_ty_8 = 76;
pub const FspLaunchCmdDefineDosDevice: _bindgen_ty_8 = 68;
pub const FspLaunchCmdQuit: _bindgen_ty_8 = 81;
pub type _bindgen_ty_8 = ::std::os::raw::c_int;
pub const FspLaunchCmdSuccess: _bindgen_ty_9 = 36;
pub const FspLaunchCmdFailure: _bindgen_ty_9 = 33;
pub type _bindgen_ty_9 = ::std::os::raw::c_int;
extern "C" {
    #[doc = " @group Launch Control\n/\n/**\n Call launcher pipe.\n\n This function is used to send a command to the launcher and receive a response.\n\n @param Command\n     Launcher command to send. For example, the 'L' launcher command instructs\n     the launcher to list all running service instances.\n @param Argc\n     Command argument count. May be 0.\n @param Argv\n     Command argument array. May be NULL.\n @param Argl\n     Command argument length array. May be NULL. If this is NULL all command arguments\n     are assumed to be NULL-terminated strings. It is also possible for specific arguments\n     to be NULL-terminated; in this case pass -1 in the corresponding Argl position.\n @param Buffer\n     Buffer that receives the command response. May be NULL.\n @param PSize\n     Pointer to a ULONG. On input it contains the size of the Buffer. On output it\n     contains the number of bytes transferred. May be NULL.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchCallLauncherPipe(
        Command: WCHAR,
        Argc: ULONG,
        Argv: *mut PWSTR,
        Argl: *mut ULONG,
        Buffer: PWSTR,
        PSize: PULONG,
        PLauncherError: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Call launcher pipe.\n\n This function is used to send a command to the launcher and receive a response.\n\n @param Command\n     Launcher command to send. For example, the 'L' launcher command instructs\n     the launcher to list all running service instances.\n @param Argc\n     Command argument count. May be 0.\n @param Argv\n     Command argument array. May be NULL.\n @param Argl\n     Command argument length array. May be NULL. If this is NULL all command arguments\n     are assumed to be NULL-terminated strings. It is also possible for specific arguments\n     to be NULL-terminated; in this case pass -1 in the corresponding Argl position.\n @param Buffer\n     Buffer that receives the command response. May be NULL.\n @param PSize\n     Pointer to a ULONG. On input it contains the size of the Buffer. On output it\n     contains the number of bytes transferred. May be NULL.\n @param AllowImpersonation\n     Allow caller to be impersonated by launcher.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchCallLauncherPipeEx(
        Command: WCHAR,
        Argc: ULONG,
        Argv: *mut PWSTR,
        Argl: *mut ULONG,
        Buffer: PWSTR,
        PSize: PULONG,
        AllowImpersonation: BOOLEAN,
        PLauncherError: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Start a service instance.\n\n @param ClassName\n     Class name of the service instance to start.\n @param InstanceName\n     Instance name of the service instance to start.\n @param Argc\n     Service instance argument count. May be 0.\n @param Argv\n     Service instance argument array. May be NULL.\n @param HasSecret\n     Whether the last argument in Argv is assumed to be a secret (e.g. password) or not.\n     Secrets are passed to service instances through standard input rather than the command\n     line.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchStart(
        ClassName: PWSTR,
        InstanceName: PWSTR,
        Argc: ULONG,
        Argv: *mut PWSTR,
        HasSecret: BOOLEAN,
        PLauncherError: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Start a service instance.\n\n @param ClassName\n     Class name of the service instance to start.\n @param InstanceName\n     Instance name of the service instance to start.\n @param Argc\n     Service instance argument count. May be 0.\n @param Argv\n     Service instance argument array. May be NULL.\n @param HasSecret\n     Whether the last argument in Argv is assumed to be a secret (e.g. password) or not.\n     Secrets are passed to service instances through standard input rather than the command\n     line.\n @param AllowImpersonation\n     Allow caller to be impersonated by launcher.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchStartEx(
        ClassName: PWSTR,
        InstanceName: PWSTR,
        Argc: ULONG,
        Argv: *mut PWSTR,
        HasSecret: BOOLEAN,
        AllowImpersonation: BOOLEAN,
        PLauncherError: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Stop a service instance.\n\n @param ClassName\n     Class name of the service instance to stop.\n @param InstanceName\n     Instance name of the service instance to stop.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchStop(ClassName: PWSTR, InstanceName: PWSTR, PLauncherError: PULONG)
        -> NTSTATUS;
}
extern "C" {
    #[doc = " Get information about a service instance.\n\n The information is a list of NULL-terminated strings: the class name of the service instance,\n the instance name of the service instance and the full command line used to start the service\n instance.\n\n @param ClassName\n     Class name of the service instance to stop.\n @param InstanceName\n     Instance name of the service instance to stop.\n @param Buffer\n     Buffer that receives the command response. May be NULL.\n @param PSize\n     Pointer to a ULONG. On input it contains the size of the Buffer. On output it\n     contains the number of bytes transferred. May be NULL.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchGetInfo(
        ClassName: PWSTR,
        InstanceName: PWSTR,
        Buffer: PWSTR,
        PSize: PULONG,
        PLauncherError: PULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " List service instances.\n\n The information is a list of pairs of NULL-terminated strings. Each pair contains the class\n name and instance name of a service instance. All currently running service instances are\n listed.\n\n @param Buffer\n     Buffer that receives the command response. May be NULL.\n @param PSize\n     Pointer to a ULONG. On input it contains the size of the Buffer. On output it\n     contains the number of bytes transferred. May be NULL.\n @param PLauncherError\n     Receives the launcher error if any. This is always a Win32 error code. May not be NULL.\n @return\n     STATUS_SUCCESS if the command is sent successfully to the launcher, even if the launcher\n     returns an error. Other status codes indicate a communication error. Launcher errors are\n     reported through PLauncherError."]
    pub fn FspLaunchGetNameList(Buffer: PWSTR, PSize: PULONG, PLauncherError: PULONG) -> NTSTATUS;
}
#[doc = " Service registry record."]
#[repr(C)]
#[derive(Debug)]
pub struct _FSP_LAUNCH_REG_RECORD {
    pub Agent: PWSTR,
    pub Executable: PWSTR,
    pub CommandLine: PWSTR,
    pub WorkDirectory: PWSTR,
    pub RunAs: PWSTR,
    pub Security: PWSTR,
    pub AuthPackage: PWSTR,
    pub Stderr: PWSTR,
    pub Reserved0: [PVOID; 4usize],
    pub JobControl: ULONG,
    pub Credentials: ULONG,
    pub AuthPackageId: ULONG,
    pub Recovery: ULONG,
    pub Reserved1: [ULONG; 4usize],
    pub Buffer: __IncompleteArrayField<UINT8>,
}
#[test]
fn bindgen_test_layout__FSP_LAUNCH_REG_RECORD() {
    const UNINIT: ::std::mem::MaybeUninit<_FSP_LAUNCH_REG_RECORD> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_FSP_LAUNCH_REG_RECORD>(),
        128usize,
        concat!("Size of: ", stringify!(_FSP_LAUNCH_REG_RECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_LAUNCH_REG_RECORD>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_LAUNCH_REG_RECORD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Agent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Agent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Executable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Executable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).CommandLine) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(CommandLine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).WorkDirectory) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(WorkDirectory)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).RunAs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(RunAs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Security) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Security)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthPackage) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(AuthPackage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Stderr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Stderr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved0) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Reserved0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).JobControl) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(JobControl)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Credentials) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Credentials)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).AuthPackageId) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(AuthPackageId)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Recovery) as usize - ptr as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Recovery)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Reserved1) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_FSP_LAUNCH_REG_RECORD),
            "::",
            stringify!(Buffer)
        )
    );
}
impl Default for _FSP_LAUNCH_REG_RECORD {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Service registry record."]
pub type FSP_LAUNCH_REG_RECORD = _FSP_LAUNCH_REG_RECORD;
extern "C" {
    #[doc = " Add/change/delete a service registry record.\n\n @param ClassName\n     The service class name.\n @param Record\n     The record to set in the registry. If NULL, the registry record is deleted.\n @return\n     STATUS_SUCCESS or error code."]
    pub fn FspLaunchRegSetRecord(
        ClassName: PWSTR,
        Record: *const FSP_LAUNCH_REG_RECORD,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Get a service registry record.\n\n @param ClassName\n     The service class name.\n @param Agent\n     The name of the agent that is retrieving the service record. This API matches\n     the supplied Agent against the Agent in the service record and it only returns\n     the record if they match. Pass NULL to match any Agent.\n @param PRecord\n     Pointer to a record pointer. Memory for the service record will be allocated\n     and a pointer to it will be stored at this address. This memory must be later\n     freed using FspLaunchRegFreeRecord.\n @return\n     STATUS_SUCCESS or error code.\n @see\n     FspLaunchRegFreeRecord"]
    pub fn FspLaunchRegGetRecord(
        ClassName: PWSTR,
        Agent: PWSTR,
        PRecord: *mut *mut FSP_LAUNCH_REG_RECORD,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Free a service registry record.\n\n @param Record\n     The service record to free.\n @see\n     FspLaunchRegGetRecord"]
    pub fn FspLaunchRegFreeRecord(Record: *mut FSP_LAUNCH_REG_RECORD);
}
