/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const FSP_FSCTL_PRODUCT_NAME: &[u8; 7usize] = b"WinFsp\0";
pub const FSP_FSCTL_PRODUCT_FILE_NAME: &[u8; 7usize] = b"winfsp\0";
pub const FSP_FSCTL_DRIVER_NAME: &[u8; 7usize] = b"WinFsp\0";
pub const FSP_FSCTL_DISK_DEVICE_NAME: &[u8; 12usize] = b"WinFsp.Disk\0";
pub const FSP_FSCTL_NET_DEVICE_NAME: &[u8; 11usize] = b"WinFsp.Net\0";
pub const FSP_FSCTL_MUP_DEVICE_NAME: &[u8; 11usize] = b"WinFsp.Mup\0";
pub const FSP_FSCTL_PRODUCT_REGKEY: &[u8; 16usize] = b"Software\\WinFsp\0";
pub const FSP_FSCTL_PRODUCT_REGKEY_WOW64: u32 = 512;
pub const FSP_FSCTL_PRODUCT_FULL_REGKEY: &[u8; 28usize] = b"Software\\WOW6432Node\\WinFsp\0";
pub const FSP_FSCTL_PRODUCT_FILE_ARCH: &[u8; 4usize] = b"x64\0";
pub const FSP_FSCTL_DEFAULT_ALIGNMENT: u32 = 8;
pub const FSP_FSCTL_VOLUME_PARAMS_PREFIX: &[u8; 15usize] = b"\\VolumeParams=\0";
pub const FSP_FSCTL_TRANSACT_REQ_SIZEMAX: u32 = 16320;
pub const FSP_FSCTL_TRANSACT_RSP_SIZEMAX: u32 = 16384;
pub const FSP_FSCTL_TRANSACT_BATCH_BUFFER_SIZEMIN: u32 = 65536;
pub const FSP_FSCTL_TRANSACT_BUFFER_SIZEMIN: u32 = 16320;
pub const FSP_FSCTL_DEVICECONTROL_SIZEMAX: u32 = 4096;
pub const FSP_DLLNAME: &[u8; 15usize] = b"winfsp-x64.dll\0";
pub const FSP_DLLPATH: &[u8; 19usize] = b"bin\\winfsp-x64.dll\0";
pub type va_list = *mut ::std::os::raw::c_char;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type PHANDLE = *mut HANDLE;
pub type BOOLEAN = BYTE;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    fn test_field_Flink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flink) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
            )
        );
    }
    test_field_Flink();
    fn test_field_Blink() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_LIST_ENTRY>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Blink) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
            )
        );
    }
    test_field_Blink();
}
impl Default for _LIST_ENTRY {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type LIST_ENTRY = _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    fn test_field_Data1() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Data1) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
            )
        );
    }
    test_field_Data1();
    fn test_field_Data2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Data2) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
            )
        );
    }
    test_field_Data2();
    fn test_field_Data3() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Data3) as usize - ptr as usize
            },
            6usize,
            concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
            )
        );
    }
    test_field_Data3();
    fn test_field_Data4() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GUID>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Data4) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
            )
        );
    }
    test_field_Data4();
}
pub type GUID = _GUID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type ACCESS_MASK = DWORD;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    assert_eq!(
        ::std::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::std::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    fn test_field_GenericRead() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GENERIC_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GenericRead) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
            )
        );
    }
    test_field_GenericRead();
    fn test_field_GenericWrite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GENERIC_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GenericWrite) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
            )
        );
    }
    test_field_GenericWrite();
    fn test_field_GenericExecute() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GENERIC_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GenericExecute) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
            )
        );
    }
    test_field_GenericExecute();
    fn test_field_GenericAll() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_GENERIC_MAPPING>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GenericAll) as usize - ptr as usize
            },
            12usize,
            concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
            )
        );
    }
    test_field_GenericAll();
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
pub type SECURITY_INFORMATION = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    pub Type: WORD,
    pub CreatorBackTraceIndex: WORD,
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    pub ProcessLocksList: LIST_ENTRY,
    pub EntryCount: DWORD,
    pub ContentionCount: DWORD,
    pub Flags: DWORD,
    pub CreatorBackTraceIndexHigh: WORD,
    pub SpareWORD: WORD,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION_DEBUG() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        48usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    fn test_field_Type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Type) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Type)
            )
        );
    }
    test_field_Type();
    fn test_field_CreatorBackTraceIndex() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CreatorBackTraceIndex) as usize - ptr as usize
            },
            2usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndex)
            )
        );
    }
    test_field_CreatorBackTraceIndex();
    fn test_field_CriticalSection() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CriticalSection) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CriticalSection)
            )
        );
    }
    test_field_CriticalSection();
    fn test_field_ProcessLocksList() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ProcessLocksList) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ProcessLocksList)
            )
        );
    }
    test_field_ProcessLocksList();
    fn test_field_EntryCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EntryCount) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(EntryCount)
            )
        );
    }
    test_field_EntryCount();
    fn test_field_ContentionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ContentionCount) as usize - ptr as usize
            },
            36usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ContentionCount)
            )
        );
    }
    test_field_ContentionCount();
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Flags)
            )
        );
    }
    test_field_Flags();
    fn test_field_CreatorBackTraceIndexHigh() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CreatorBackTraceIndexHigh) as usize - ptr as usize
            },
            44usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndexHigh)
            )
        );
    }
    test_field_CreatorBackTraceIndexHigh();
    fn test_field_SpareWORD() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION_DEBUG>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SpareWORD) as usize - ptr as usize
            },
            46usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(SpareWORD)
            )
        );
    }
    test_field_SpareWORD();
}
impl Default for _RTL_CRITICAL_SECTION_DEBUG {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: HANDLE,
    pub LockSemaphore: HANDLE,
    pub SpinCount: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        40usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    fn test_field_DebugInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DebugInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(DebugInfo)
            )
        );
    }
    test_field_DebugInfo();
    fn test_field_LockCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LockCount) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
            )
        );
    }
    test_field_LockCount();
    fn test_field_RecursionCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RecursionCount) as usize - ptr as usize
            },
            12usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
            )
        );
    }
    test_field_RecursionCount();
    fn test_field_OwningThread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OwningThread) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
            )
        );
    }
    test_field_OwningThread();
    fn test_field_LockSemaphore() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LockSemaphore) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockSemaphore)
            )
        );
    }
    test_field_LockSemaphore();
    fn test_field_SpinCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_CRITICAL_SECTION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SpinCount) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(SpinCount)
            )
        );
    }
    test_field_SpinCount();
}
impl Default for _RTL_CRITICAL_SECTION {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
    );
    fn test_field_Ptr() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_RTL_SRWLOCK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Ptr) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_RTL_SRWLOCK),
            "::",
            stringify!(Ptr)
            )
        );
    }
    test_field_Ptr();
}
impl Default for _RTL_SRWLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
    assert_eq!(
        ::std::mem::size_of::<_FILETIME>(),
        8usize,
        concat!("Size of: ", stringify!(_FILETIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILETIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILETIME))
    );
    fn test_field_dwLowDateTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILETIME>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwLowDateTime) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwLowDateTime)
            )
        );
    }
    test_field_dwLowDateTime();
    fn test_field_dwHighDateTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILETIME>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwHighDateTime) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwHighDateTime)
            )
        );
    }
    test_field_dwHighDateTime();
}
pub type PFILETIME = *mut _FILETIME;
pub type CRITICAL_SECTION = RTL_CRITICAL_SECTION;
pub type SRWLOCK = RTL_SRWLOCK;
pub type NTSTATUS = LONG;
pub type PNTSTATUS = *mut NTSTATUS;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct SERVICE_STATUS_HANDLE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_SERVICE_STATUS_HANDLE__() {
    assert_eq!(
        ::std::mem::size_of::<SERVICE_STATUS_HANDLE__>(),
        4usize,
        concat!("Size of: ", stringify!(SERVICE_STATUS_HANDLE__))
    );
    assert_eq!(
        ::std::mem::align_of::<SERVICE_STATUS_HANDLE__>(),
        4usize,
        concat!("Alignment of ", stringify!(SERVICE_STATUS_HANDLE__))
    );
    fn test_field_unused() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<SERVICE_STATUS_HANDLE__>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(SERVICE_STATUS_HANDLE__),
            "::",
            stringify!(unused)
            )
        );
    }
    test_field_unused();
}
pub type SERVICE_STATUS_HANDLE = *mut SERVICE_STATUS_HANDLE__;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _SERVICE_STATUS {
    pub dwServiceType: DWORD,
    pub dwCurrentState: DWORD,
    pub dwControlsAccepted: DWORD,
    pub dwWin32ExitCode: DWORD,
    pub dwServiceSpecificExitCode: DWORD,
    pub dwCheckPoint: DWORD,
    pub dwWaitHint: DWORD,
}
#[test]
fn bindgen_test_layout__SERVICE_STATUS() {
    assert_eq!(
        ::std::mem::size_of::<_SERVICE_STATUS>(),
        28usize,
        concat!("Size of: ", stringify!(_SERVICE_STATUS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SERVICE_STATUS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SERVICE_STATUS))
    );
    fn test_field_dwServiceType() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwServiceType) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwServiceType)
            )
        );
    }
    test_field_dwServiceType();
    fn test_field_dwCurrentState() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwCurrentState) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwCurrentState)
            )
        );
    }
    test_field_dwCurrentState();
    fn test_field_dwControlsAccepted() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwControlsAccepted) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwControlsAccepted)
            )
        );
    }
    test_field_dwControlsAccepted();
    fn test_field_dwWin32ExitCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwWin32ExitCode) as usize - ptr as usize
            },
            12usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwWin32ExitCode)
            )
        );
    }
    test_field_dwWin32ExitCode();
    fn test_field_dwServiceSpecificExitCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwServiceSpecificExitCode) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwServiceSpecificExitCode)
            )
        );
    }
    test_field_dwServiceSpecificExitCode();
    fn test_field_dwCheckPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwCheckPoint) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwCheckPoint)
            )
        );
    }
    test_field_dwCheckPoint();
    fn test_field_dwWaitHint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_SERVICE_STATUS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).dwWaitHint) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(_SERVICE_STATUS),
            "::",
            stringify!(dwWaitHint)
            )
        );
    }
    test_field_dwWaitHint();
}
pub type SERVICE_STATUS = _SERVICE_STATUS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_STATUS_BLOCK {
    pub __bindgen_anon_1: _IO_STATUS_BLOCK__bindgen_ty_1,
    pub Information: ULONG_PTR,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IO_STATUS_BLOCK__bindgen_ty_1 {
    pub Status: NTSTATUS,
    pub Pointer: PVOID,
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_STATUS_BLOCK__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK__bindgen_ty_1))
    );
    fn test_field_Status() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_STATUS_BLOCK__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Status)
            )
        );
    }
    test_field_Status();
    fn test_field_Pointer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_STATUS_BLOCK__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Pointer) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK__bindgen_ty_1),
            "::",
            stringify!(Pointer)
            )
        );
    }
    test_field_Pointer();
}
impl Default for _IO_STATUS_BLOCK__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__IO_STATUS_BLOCK() {
    assert_eq!(
        ::std::mem::size_of::<_IO_STATUS_BLOCK>(),
        16usize,
        concat!("Size of: ", stringify!(_IO_STATUS_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_STATUS_BLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_STATUS_BLOCK))
    );
    fn test_field_Information() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_IO_STATUS_BLOCK>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Information) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_IO_STATUS_BLOCK),
            "::",
            stringify!(Information)
            )
        );
    }
    test_field_Information();
}
impl Default for _IO_STATUS_BLOCK {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type PIO_STATUS_BLOCK = *mut _IO_STATUS_BLOCK;
extern "C" {
    pub static FspFsctlDeviceClassGuid: GUID;
}
extern "C" {
    pub static FspFsvrtDeviceClassGuid: GUID;
}
pub const FspFsctlTransactReservedKind: _bindgen_ty_5 = 0;
pub const FspFsctlTransactCreateKind: _bindgen_ty_5 = 1;
pub const FspFsctlTransactOverwriteKind: _bindgen_ty_5 = 2;
pub const FspFsctlTransactCleanupKind: _bindgen_ty_5 = 3;
pub const FspFsctlTransactCloseKind: _bindgen_ty_5 = 4;
pub const FspFsctlTransactReadKind: _bindgen_ty_5 = 5;
pub const FspFsctlTransactWriteKind: _bindgen_ty_5 = 6;
pub const FspFsctlTransactQueryInformationKind: _bindgen_ty_5 = 7;
pub const FspFsctlTransactSetInformationKind: _bindgen_ty_5 = 8;
pub const FspFsctlTransactQueryEaKind: _bindgen_ty_5 = 9;
pub const FspFsctlTransactSetEaKind: _bindgen_ty_5 = 10;
pub const FspFsctlTransactFlushBuffersKind: _bindgen_ty_5 = 11;
pub const FspFsctlTransactQueryVolumeInformationKind: _bindgen_ty_5 = 12;
pub const FspFsctlTransactSetVolumeInformationKind: _bindgen_ty_5 = 13;
pub const FspFsctlTransactQueryDirectoryKind: _bindgen_ty_5 = 14;
pub const FspFsctlTransactFileSystemControlKind: _bindgen_ty_5 = 15;
pub const FspFsctlTransactDeviceControlKind: _bindgen_ty_5 = 16;
pub const FspFsctlTransactShutdownKind: _bindgen_ty_5 = 17;
pub const FspFsctlTransactLockControlKind: _bindgen_ty_5 = 18;
pub const FspFsctlTransactQuerySecurityKind: _bindgen_ty_5 = 19;
pub const FspFsctlTransactSetSecurityKind: _bindgen_ty_5 = 20;
pub const FspFsctlTransactQueryStreamInformationKind: _bindgen_ty_5 = 21;
pub const FspFsctlTransactKindCount: _bindgen_ty_5 = 22;
pub type _bindgen_ty_5 = ::std::os::raw::c_int;
pub const FspFsctlTransactTimeoutMinimum: _bindgen_ty_6 = 1000;
pub const FspFsctlTransactTimeoutMaximum: _bindgen_ty_6 = 10000;
pub const FspFsctlTransactTimeoutDefault: _bindgen_ty_6 = 1000;
pub const FspFsctlIrpTimeoutMinimum: _bindgen_ty_6 = 60000;
pub const FspFsctlIrpTimeoutMaximum: _bindgen_ty_6 = 600000;
pub const FspFsctlIrpTimeoutDefault: _bindgen_ty_6 = 300000;
pub const FspFsctlIrpTimeoutDebug: _bindgen_ty_6 = 142;
pub const FspFsctlIrpCapacityMinimum: _bindgen_ty_6 = 100;
pub const FspFsctlIrpCapacityMaximum: _bindgen_ty_6 = 1000;
pub const FspFsctlIrpCapacityDefault: _bindgen_ty_6 = 1000;
pub type _bindgen_ty_6 = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_FSCTL_VOLUME_PARAMS_V0 {
    pub Version: UINT16,
    pub SectorSize: UINT16,
    pub SectorsPerAllocationUnit: UINT16,
    pub MaxComponentLength: UINT16,
    pub VolumeCreationTime: UINT64,
    pub VolumeSerialNumber: UINT32,
    pub TransactTimeout: UINT32,
    pub IrpTimeout: UINT32,
    pub IrpCapacity: UINT32,
    pub FileInfoTimeout: UINT32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Prefix: [WCHAR; 192usize],
    pub FileSystemName: [WCHAR; 16usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_VOLUME_PARAMS_V0() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_VOLUME_PARAMS_V0>(),
        456usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_VOLUME_PARAMS_V0))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_VOLUME_PARAMS_V0>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_VOLUME_PARAMS_V0))
    );
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_SectorSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize
            },
            2usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(SectorSize)
            )
        );
    }
    test_field_SectorSize();
    fn test_field_SectorsPerAllocationUnit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(SectorsPerAllocationUnit)
            )
        );
    }
    test_field_SectorsPerAllocationUnit();
    fn test_field_MaxComponentLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MaxComponentLength) as usize - ptr as usize
            },
            6usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(MaxComponentLength)
            )
        );
    }
    test_field_MaxComponentLength();
    fn test_field_VolumeCreationTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(VolumeCreationTime)
            )
        );
    }
    test_field_VolumeCreationTime();
    fn test_field_VolumeSerialNumber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(VolumeSerialNumber)
            )
        );
    }
    test_field_VolumeSerialNumber();
    fn test_field_TransactTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).TransactTimeout) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(TransactTimeout)
            )
        );
    }
    test_field_TransactTimeout();
    fn test_field_IrpTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IrpTimeout) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(IrpTimeout)
            )
        );
    }
    test_field_IrpTimeout();
    fn test_field_IrpCapacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IrpCapacity) as usize - ptr as usize
            },
            28usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(IrpCapacity)
            )
        );
    }
    test_field_IrpCapacity();
    fn test_field_FileInfoTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfoTimeout) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(FileInfoTimeout)
            )
        );
    }
    test_field_FileInfoTimeout();
    fn test_field_Prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Prefix) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(Prefix)
            )
        );
    }
    test_field_Prefix();
    fn test_field_FileSystemName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS_V0>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize
            },
            424usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS_V0),
            "::",
            stringify!(FileSystemName)
            )
        );
    }
    test_field_FileSystemName();
}
impl Default for FSP_FSCTL_VOLUME_PARAMS_V0 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FSP_FSCTL_VOLUME_PARAMS_V0 {
    #[inline]
    pub fn CaseSensitiveSearch(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitiveSearch(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedNames(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedNames(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnicodeOnDisk(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnicodeOnDisk(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistentAcls(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistentAcls(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePoints(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePoints(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePointsAccessCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePointsAccessCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NamedStreams(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NamedStreams(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardLinks(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardLinks(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnlyVolume(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnlyVolume(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostCleanupWhenModifiedOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostCleanupWhenModifiedOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryPattern(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryPattern(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AlwaysUseDoubleBuffering(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AlwaysUseDoubleBuffering(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryFileName(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryFileName(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlushAndPurgeOnCleanup(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlushAndPurgeOnCleanup(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceControl(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceControl(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsUserContext2(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsUserContext2(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsFullContext(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsFullContext(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmNoReparsePointsDirCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmNoReparsePointsDirCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_UmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowOpenInKernelMode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowOpenInKernelMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WslFeatures(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WslFeatures(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectoryMarkerAsNextOffset(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectoryMarkerAsNextOffset(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RejectIrpPriorToTransact0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RejectIrpPriorToTransact0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsPosixUnlinkRename(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsPosixUnlinkRename(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostDispositionWhenNecessaryOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostDispositionWhenNecessaryOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseSensitiveSearch: UINT32,
        CasePreservedNames: UINT32,
        UnicodeOnDisk: UINT32,
        PersistentAcls: UINT32,
        ReparsePoints: UINT32,
        ReparsePointsAccessCheck: UINT32,
        NamedStreams: UINT32,
        HardLinks: UINT32,
        ExtendedAttributes: UINT32,
        ReadOnlyVolume: UINT32,
        PostCleanupWhenModifiedOnly: UINT32,
        PassQueryDirectoryPattern: UINT32,
        AlwaysUseDoubleBuffering: UINT32,
        PassQueryDirectoryFileName: UINT32,
        FlushAndPurgeOnCleanup: UINT32,
        DeviceControl: UINT32,
        UmFileContextIsUserContext2: UINT32,
        UmFileContextIsFullContext: UINT32,
        UmNoReparsePointsDirCheck: UINT32,
        UmReservedFlags: UINT32,
        AllowOpenInKernelMode: UINT32,
        CasePreservedExtendedAttributes: UINT32,
        WslFeatures: UINT32,
        DirectoryMarkerAsNextOffset: UINT32,
        RejectIrpPriorToTransact0: UINT32,
        SupportsPosixUnlinkRename: UINT32,
        PostDispositionWhenNecessaryOnly: UINT32,
        KmReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseSensitiveSearch: u32 = unsafe { ::std::mem::transmute(CaseSensitiveSearch) };
            CaseSensitiveSearch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CasePreservedNames: u32 = unsafe { ::std::mem::transmute(CasePreservedNames) };
            CasePreservedNames as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UnicodeOnDisk: u32 = unsafe { ::std::mem::transmute(UnicodeOnDisk) };
            UnicodeOnDisk as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PersistentAcls: u32 = unsafe { ::std::mem::transmute(PersistentAcls) };
            PersistentAcls as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReparsePoints: u32 = unsafe { ::std::mem::transmute(ReparsePoints) };
            ReparsePoints as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ReparsePointsAccessCheck: u32 =
                unsafe { ::std::mem::transmute(ReparsePointsAccessCheck) };
            ReparsePointsAccessCheck as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NamedStreams: u32 = unsafe { ::std::mem::transmute(NamedStreams) };
            NamedStreams as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HardLinks: u32 = unsafe { ::std::mem::transmute(HardLinks) };
            HardLinks as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ExtendedAttributes: u32 = unsafe { ::std::mem::transmute(ExtendedAttributes) };
            ExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ReadOnlyVolume: u32 = unsafe { ::std::mem::transmute(ReadOnlyVolume) };
            ReadOnlyVolume as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PostCleanupWhenModifiedOnly: u32 =
                unsafe { ::std::mem::transmute(PostCleanupWhenModifiedOnly) };
            PostCleanupWhenModifiedOnly as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PassQueryDirectoryPattern: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryPattern) };
            PassQueryDirectoryPattern as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let AlwaysUseDoubleBuffering: u32 =
                unsafe { ::std::mem::transmute(AlwaysUseDoubleBuffering) };
            AlwaysUseDoubleBuffering as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PassQueryDirectoryFileName: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryFileName) };
            PassQueryDirectoryFileName as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FlushAndPurgeOnCleanup: u32 =
                unsafe { ::std::mem::transmute(FlushAndPurgeOnCleanup) };
            FlushAndPurgeOnCleanup as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DeviceControl: u32 = unsafe { ::std::mem::transmute(DeviceControl) };
            DeviceControl as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UmFileContextIsUserContext2: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsUserContext2) };
            UmFileContextIsUserContext2 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UmFileContextIsFullContext: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsFullContext) };
            UmFileContextIsFullContext as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let UmNoReparsePointsDirCheck: u32 =
                unsafe { ::std::mem::transmute(UmNoReparsePointsDirCheck) };
            UmNoReparsePointsDirCheck as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let UmReservedFlags: u32 = unsafe { ::std::mem::transmute(UmReservedFlags) };
            UmReservedFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AllowOpenInKernelMode: u32 =
                unsafe { ::std::mem::transmute(AllowOpenInKernelMode) };
            AllowOpenInKernelMode as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CasePreservedExtendedAttributes: u32 =
                unsafe { ::std::mem::transmute(CasePreservedExtendedAttributes) };
            CasePreservedExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let WslFeatures: u32 = unsafe { ::std::mem::transmute(WslFeatures) };
            WslFeatures as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let DirectoryMarkerAsNextOffset: u32 =
                unsafe { ::std::mem::transmute(DirectoryMarkerAsNextOffset) };
            DirectoryMarkerAsNextOffset as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RejectIrpPriorToTransact0: u32 =
                unsafe { ::std::mem::transmute(RejectIrpPriorToTransact0) };
            RejectIrpPriorToTransact0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let SupportsPosixUnlinkRename: u32 =
                unsafe { ::std::mem::transmute(SupportsPosixUnlinkRename) };
            SupportsPosixUnlinkRename as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PostDispositionWhenNecessaryOnly: u32 =
                unsafe { ::std::mem::transmute(PostDispositionWhenNecessaryOnly) };
            PostDispositionWhenNecessaryOnly as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let KmReservedFlags: u32 = unsafe { ::std::mem::transmute(KmReservedFlags) };
            KmReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_FSCTL_VOLUME_PARAMS {
    pub Version: UINT16,
    pub SectorSize: UINT16,
    pub SectorsPerAllocationUnit: UINT16,
    pub MaxComponentLength: UINT16,
    pub VolumeCreationTime: UINT64,
    pub VolumeSerialNumber: UINT32,
    pub TransactTimeout: UINT32,
    pub IrpTimeout: UINT32,
    pub IrpCapacity: UINT32,
    pub FileInfoTimeout: UINT32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub Prefix: [WCHAR; 192usize],
    pub FileSystemName: [WCHAR; 16usize],
    pub _bitfield_align_2: [u32; 0],
    pub _bitfield_2: __BindgenBitfieldUnit<[u8; 4usize]>,
    pub VolumeInfoTimeout: UINT32,
    pub DirInfoTimeout: UINT32,
    pub SecurityTimeout: UINT32,
    pub StreamInfoTimeout: UINT32,
    pub EaTimeout: UINT32,
    pub FsextControlCode: UINT32,
    pub Reserved32: [UINT32; 1usize],
    pub Reserved64: [UINT64; 2usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_VOLUME_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_VOLUME_PARAMS>(),
        504usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_VOLUME_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_VOLUME_PARAMS>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_VOLUME_PARAMS))
    );
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_SectorSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SectorSize) as usize - ptr as usize
            },
            2usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(SectorSize)
            )
        );
    }
    test_field_SectorSize();
    fn test_field_SectorsPerAllocationUnit() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SectorsPerAllocationUnit) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(SectorsPerAllocationUnit)
            )
        );
    }
    test_field_SectorsPerAllocationUnit();
    fn test_field_MaxComponentLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MaxComponentLength) as usize - ptr as usize
            },
            6usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(MaxComponentLength)
            )
        );
    }
    test_field_MaxComponentLength();
    fn test_field_VolumeCreationTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeCreationTime) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(VolumeCreationTime)
            )
        );
    }
    test_field_VolumeCreationTime();
    fn test_field_VolumeSerialNumber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeSerialNumber) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(VolumeSerialNumber)
            )
        );
    }
    test_field_VolumeSerialNumber();
    fn test_field_TransactTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).TransactTimeout) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(TransactTimeout)
            )
        );
    }
    test_field_TransactTimeout();
    fn test_field_IrpTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IrpTimeout) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(IrpTimeout)
            )
        );
    }
    test_field_IrpTimeout();
    fn test_field_IrpCapacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IrpCapacity) as usize - ptr as usize
            },
            28usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(IrpCapacity)
            )
        );
    }
    test_field_IrpCapacity();
    fn test_field_FileInfoTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfoTimeout) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(FileInfoTimeout)
            )
        );
    }
    test_field_FileInfoTimeout();
    fn test_field_Prefix() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Prefix) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Prefix)
            )
        );
    }
    test_field_Prefix();
    fn test_field_FileSystemName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileSystemName) as usize - ptr as usize
            },
            424usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(FileSystemName)
            )
        );
    }
    test_field_FileSystemName();
    fn test_field_VolumeInfoTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeInfoTimeout) as usize - ptr as usize
            },
            460usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(VolumeInfoTimeout)
            )
        );
    }
    test_field_VolumeInfoTimeout();
    fn test_field_DirInfoTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DirInfoTimeout) as usize - ptr as usize
            },
            464usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(DirInfoTimeout)
            )
        );
    }
    test_field_DirInfoTimeout();
    fn test_field_SecurityTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityTimeout) as usize - ptr as usize
            },
            468usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(SecurityTimeout)
            )
        );
    }
    test_field_SecurityTimeout();
    fn test_field_StreamInfoTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).StreamInfoTimeout) as usize - ptr as usize
            },
            472usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(StreamInfoTimeout)
            )
        );
    }
    test_field_StreamInfoTimeout();
    fn test_field_EaTimeout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EaTimeout) as usize - ptr as usize
            },
            476usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(EaTimeout)
            )
        );
    }
    test_field_EaTimeout();
    fn test_field_FsextControlCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FsextControlCode) as usize - ptr as usize
            },
            480usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(FsextControlCode)
            )
        );
    }
    test_field_FsextControlCode();
    fn test_field_Reserved32() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reserved32) as usize - ptr as usize
            },
            484usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Reserved32)
            )
        );
    }
    test_field_Reserved32();
    fn test_field_Reserved64() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_PARAMS>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reserved64) as usize - ptr as usize
            },
            488usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_PARAMS),
            "::",
            stringify!(Reserved64)
            )
        );
    }
    test_field_Reserved64();
}
impl Default for FSP_FSCTL_VOLUME_PARAMS {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl FSP_FSCTL_VOLUME_PARAMS {
    #[inline]
    pub fn CaseSensitiveSearch(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitiveSearch(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedNames(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedNames(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UnicodeOnDisk(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UnicodeOnDisk(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PersistentAcls(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PersistentAcls(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePoints(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePoints(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReparsePointsAccessCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReparsePointsAccessCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NamedStreams(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NamedStreams(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HardLinks(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HardLinks(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReadOnlyVolume(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ReadOnlyVolume(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostCleanupWhenModifiedOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostCleanupWhenModifiedOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryPattern(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryPattern(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AlwaysUseDoubleBuffering(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AlwaysUseDoubleBuffering(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PassQueryDirectoryFileName(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PassQueryDirectoryFileName(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FlushAndPurgeOnCleanup(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_FlushAndPurgeOnCleanup(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DeviceControl(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeviceControl(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsUserContext2(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsUserContext2(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmFileContextIsFullContext(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmFileContextIsFullContext(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmNoReparsePointsDirCheck(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UmNoReparsePointsDirCheck(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_UmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowOpenInKernelMode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowOpenInKernelMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CasePreservedExtendedAttributes(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CasePreservedExtendedAttributes(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn WslFeatures(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_WslFeatures(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirectoryMarkerAsNextOffset(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirectoryMarkerAsNextOffset(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RejectIrpPriorToTransact0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(28usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RejectIrpPriorToTransact0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(28usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SupportsPosixUnlinkRename(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SupportsPosixUnlinkRename(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PostDispositionWhenNecessaryOnly(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PostDispositionWhenNecessaryOnly(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KmReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KmReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseSensitiveSearch: UINT32,
        CasePreservedNames: UINT32,
        UnicodeOnDisk: UINT32,
        PersistentAcls: UINT32,
        ReparsePoints: UINT32,
        ReparsePointsAccessCheck: UINT32,
        NamedStreams: UINT32,
        HardLinks: UINT32,
        ExtendedAttributes: UINT32,
        ReadOnlyVolume: UINT32,
        PostCleanupWhenModifiedOnly: UINT32,
        PassQueryDirectoryPattern: UINT32,
        AlwaysUseDoubleBuffering: UINT32,
        PassQueryDirectoryFileName: UINT32,
        FlushAndPurgeOnCleanup: UINT32,
        DeviceControl: UINT32,
        UmFileContextIsUserContext2: UINT32,
        UmFileContextIsFullContext: UINT32,
        UmNoReparsePointsDirCheck: UINT32,
        UmReservedFlags: UINT32,
        AllowOpenInKernelMode: UINT32,
        CasePreservedExtendedAttributes: UINT32,
        WslFeatures: UINT32,
        DirectoryMarkerAsNextOffset: UINT32,
        RejectIrpPriorToTransact0: UINT32,
        SupportsPosixUnlinkRename: UINT32,
        PostDispositionWhenNecessaryOnly: UINT32,
        KmReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseSensitiveSearch: u32 = unsafe { ::std::mem::transmute(CaseSensitiveSearch) };
            CaseSensitiveSearch as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CasePreservedNames: u32 = unsafe { ::std::mem::transmute(CasePreservedNames) };
            CasePreservedNames as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let UnicodeOnDisk: u32 = unsafe { ::std::mem::transmute(UnicodeOnDisk) };
            UnicodeOnDisk as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let PersistentAcls: u32 = unsafe { ::std::mem::transmute(PersistentAcls) };
            PersistentAcls as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let ReparsePoints: u32 = unsafe { ::std::mem::transmute(ReparsePoints) };
            ReparsePoints as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let ReparsePointsAccessCheck: u32 =
                unsafe { ::std::mem::transmute(ReparsePointsAccessCheck) };
            ReparsePointsAccessCheck as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let NamedStreams: u32 = unsafe { ::std::mem::transmute(NamedStreams) };
            NamedStreams as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let HardLinks: u32 = unsafe { ::std::mem::transmute(HardLinks) };
            HardLinks as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let ExtendedAttributes: u32 = unsafe { ::std::mem::transmute(ExtendedAttributes) };
            ExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let ReadOnlyVolume: u32 = unsafe { ::std::mem::transmute(ReadOnlyVolume) };
            ReadOnlyVolume as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let PostCleanupWhenModifiedOnly: u32 =
                unsafe { ::std::mem::transmute(PostCleanupWhenModifiedOnly) };
            PostCleanupWhenModifiedOnly as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let PassQueryDirectoryPattern: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryPattern) };
            PassQueryDirectoryPattern as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let AlwaysUseDoubleBuffering: u32 =
                unsafe { ::std::mem::transmute(AlwaysUseDoubleBuffering) };
            AlwaysUseDoubleBuffering as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let PassQueryDirectoryFileName: u32 =
                unsafe { ::std::mem::transmute(PassQueryDirectoryFileName) };
            PassQueryDirectoryFileName as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let FlushAndPurgeOnCleanup: u32 =
                unsafe { ::std::mem::transmute(FlushAndPurgeOnCleanup) };
            FlushAndPurgeOnCleanup as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let DeviceControl: u32 = unsafe { ::std::mem::transmute(DeviceControl) };
            DeviceControl as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let UmFileContextIsUserContext2: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsUserContext2) };
            UmFileContextIsUserContext2 as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UmFileContextIsFullContext: u32 =
                unsafe { ::std::mem::transmute(UmFileContextIsFullContext) };
            UmFileContextIsFullContext as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let UmNoReparsePointsDirCheck: u32 =
                unsafe { ::std::mem::transmute(UmNoReparsePointsDirCheck) };
            UmNoReparsePointsDirCheck as u64
        });
        __bindgen_bitfield_unit.set(19usize, 5u8, {
            let UmReservedFlags: u32 = unsafe { ::std::mem::transmute(UmReservedFlags) };
            UmReservedFlags as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let AllowOpenInKernelMode: u32 =
                unsafe { ::std::mem::transmute(AllowOpenInKernelMode) };
            AllowOpenInKernelMode as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let CasePreservedExtendedAttributes: u32 =
                unsafe { ::std::mem::transmute(CasePreservedExtendedAttributes) };
            CasePreservedExtendedAttributes as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let WslFeatures: u32 = unsafe { ::std::mem::transmute(WslFeatures) };
            WslFeatures as u64
        });
        __bindgen_bitfield_unit.set(27usize, 1u8, {
            let DirectoryMarkerAsNextOffset: u32 =
                unsafe { ::std::mem::transmute(DirectoryMarkerAsNextOffset) };
            DirectoryMarkerAsNextOffset as u64
        });
        __bindgen_bitfield_unit.set(28usize, 1u8, {
            let RejectIrpPriorToTransact0: u32 =
                unsafe { ::std::mem::transmute(RejectIrpPriorToTransact0) };
            RejectIrpPriorToTransact0 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let SupportsPosixUnlinkRename: u32 =
                unsafe { ::std::mem::transmute(SupportsPosixUnlinkRename) };
            SupportsPosixUnlinkRename as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let PostDispositionWhenNecessaryOnly: u32 =
                unsafe { ::std::mem::transmute(PostDispositionWhenNecessaryOnly) };
            PostDispositionWhenNecessaryOnly as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let KmReservedFlags: u32 = unsafe { ::std::mem::transmute(KmReservedFlags) };
            KmReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
    #[inline]
    pub fn VolumeInfoTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_VolumeInfoTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirInfoTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DirInfoTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SecurityTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SecurityTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StreamInfoTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StreamInfoTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EaTimeoutValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EaTimeoutValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn KmAdditionalReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_2.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_KmAdditionalReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_2.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_2(
        VolumeInfoTimeoutValid: UINT32,
        DirInfoTimeoutValid: UINT32,
        SecurityTimeoutValid: UINT32,
        StreamInfoTimeoutValid: UINT32,
        EaTimeoutValid: UINT32,
        KmAdditionalReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let VolumeInfoTimeoutValid: u32 =
                unsafe { ::std::mem::transmute(VolumeInfoTimeoutValid) };
            VolumeInfoTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DirInfoTimeoutValid: u32 = unsafe { ::std::mem::transmute(DirInfoTimeoutValid) };
            DirInfoTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SecurityTimeoutValid: u32 = unsafe { ::std::mem::transmute(SecurityTimeoutValid) };
            SecurityTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let StreamInfoTimeoutValid: u32 =
                unsafe { ::std::mem::transmute(StreamInfoTimeoutValid) };
            StreamInfoTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EaTimeoutValid: u32 = unsafe { ::std::mem::transmute(EaTimeoutValid) };
            EaTimeoutValid as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let KmAdditionalReservedFlags: u32 =
                unsafe { ::std::mem::transmute(KmAdditionalReservedFlags) };
            KmAdditionalReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_VOLUME_INFO {
    pub TotalSize: UINT64,
    pub FreeSize: UINT64,
    pub VolumeLabelLength: UINT16,
    pub VolumeLabel: [WCHAR; 32usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_VOLUME_INFO() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_VOLUME_INFO>(),
        88usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_VOLUME_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_VOLUME_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_VOLUME_INFO))
    );
    fn test_field_TotalSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).TotalSize) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(TotalSize)
            )
        );
    }
    test_field_TotalSize();
    fn test_field_FreeSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FreeSize) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(FreeSize)
            )
        );
    }
    test_field_FreeSize();
    fn test_field_VolumeLabelLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeLabelLength) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(VolumeLabelLength)
            )
        );
    }
    test_field_VolumeLabelLength();
    fn test_field_VolumeLabel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_VOLUME_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize
            },
            18usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_VOLUME_INFO),
            "::",
            stringify!(VolumeLabel)
            )
        );
    }
    test_field_VolumeLabel();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_FILE_INFO {
    pub FileAttributes: UINT32,
    pub ReparseTag: UINT32,
    pub AllocationSize: UINT64,
    pub FileSize: UINT64,
    pub CreationTime: UINT64,
    pub LastAccessTime: UINT64,
    pub LastWriteTime: UINT64,
    pub ChangeTime: UINT64,
    pub IndexNumber: UINT64,
    pub HardLinks: UINT32,
    pub EaSize: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_FILE_INFO() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_FILE_INFO>(),
        72usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_FILE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_FILE_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_FILE_INFO))
    );
    fn test_field_FileAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(FileAttributes)
            )
        );
    }
    test_field_FileAttributes();
    fn test_field_ReparseTag() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ReparseTag) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(ReparseTag)
            )
        );
    }
    test_field_ReparseTag();
    fn test_field_AllocationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(AllocationSize)
            )
        );
    }
    test_field_AllocationSize();
    fn test_field_FileSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(FileSize)
            )
        );
    }
    test_field_FileSize();
    fn test_field_CreationTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(CreationTime)
            )
        );
    }
    test_field_CreationTime();
    fn test_field_LastAccessTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(LastAccessTime)
            )
        );
    }
    test_field_LastAccessTime();
    fn test_field_LastWriteTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(LastWriteTime)
            )
        );
    }
    test_field_LastWriteTime();
    fn test_field_ChangeTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize
            },
            48usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(ChangeTime)
            )
        );
    }
    test_field_ChangeTime();
    fn test_field_IndexNumber() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IndexNumber) as usize - ptr as usize
            },
            56usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(IndexNumber)
            )
        );
    }
    test_field_IndexNumber();
    fn test_field_HardLinks() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).HardLinks) as usize - ptr as usize
            },
            64usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(HardLinks)
            )
        );
    }
    test_field_HardLinks();
    fn test_field_EaSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EaSize) as usize - ptr as usize
            },
            68usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_FILE_INFO),
            "::",
            stringify!(EaSize)
            )
        );
    }
    test_field_EaSize();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_FSCTL_OPEN_FILE_INFO {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub NormalizedName: PWSTR,
    pub NormalizedNameSize: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_OPEN_FILE_INFO() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_OPEN_FILE_INFO>(),
        88usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_OPEN_FILE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_OPEN_FILE_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_OPEN_FILE_INFO))
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_OPEN_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_OPEN_FILE_INFO),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
    fn test_field_NormalizedName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_OPEN_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NormalizedName) as usize - ptr as usize
            },
            72usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_OPEN_FILE_INFO),
            "::",
            stringify!(NormalizedName)
            )
        );
    }
    test_field_NormalizedName();
    fn test_field_NormalizedNameSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_OPEN_FILE_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NormalizedNameSize) as usize - ptr as usize
            },
            80usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_OPEN_FILE_INFO),
            "::",
            stringify!(NormalizedNameSize)
            )
        );
    }
    test_field_NormalizedNameSize();
}
impl Default for FSP_FSCTL_OPEN_FILE_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct FSP_FSCTL_DIR_INFO {
    pub Size: UINT16,
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub __bindgen_anon_1: FSP_FSCTL_DIR_INFO__bindgen_ty_1,
    pub FileNameBuf: __IncompleteArrayField<WCHAR>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_DIR_INFO__bindgen_ty_1 {
    pub NextOffset: UINT64,
    pub Padding: [UINT8; 24usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_DIR_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_DIR_INFO__bindgen_ty_1>(),
        24usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_DIR_INFO__bindgen_ty_1>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1)
        )
    );
    fn test_field_NextOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_DIR_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NextOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1),
            "::",
            stringify!(NextOffset)
            )
        );
    }
    test_field_NextOffset();
    fn test_field_Padding() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_DIR_INFO__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Padding) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO__bindgen_ty_1),
            "::",
            stringify!(Padding)
            )
        );
    }
    test_field_Padding();
}
impl Default for FSP_FSCTL_DIR_INFO__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_DIR_INFO() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_DIR_INFO>(),
        104usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_DIR_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_DIR_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_DIR_INFO))
    );
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_DIR_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO),
            "::",
            stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_DIR_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
    fn test_field_FileNameBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_DIR_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileNameBuf) as usize - ptr as usize
            },
            104usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_DIR_INFO),
            "::",
            stringify!(FileNameBuf)
            )
        );
    }
    test_field_FileNameBuf();
}
impl Default for FSP_FSCTL_DIR_INFO {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct FSP_FSCTL_STREAM_INFO {
    pub Size: UINT16,
    pub StreamSize: UINT64,
    pub StreamAllocationSize: UINT64,
    pub StreamNameBuf: __IncompleteArrayField<WCHAR>,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_STREAM_INFO() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_STREAM_INFO>(),
        24usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_STREAM_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_STREAM_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_STREAM_INFO))
    );
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_STREAM_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_StreamSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_STREAM_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).StreamSize) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(StreamSize)
            )
        );
    }
    test_field_StreamSize();
    fn test_field_StreamAllocationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_STREAM_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).StreamAllocationSize) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(StreamAllocationSize)
            )
        );
    }
    test_field_StreamAllocationSize();
    fn test_field_StreamNameBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_STREAM_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).StreamNameBuf) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_STREAM_INFO),
            "::",
            stringify!(StreamNameBuf)
            )
        );
    }
    test_field_StreamNameBuf();
}
#[repr(C)]
#[derive(Debug, Default)]
pub struct FSP_FSCTL_NOTIFY_INFO {
    pub Size: UINT16,
    pub Filter: UINT32,
    pub Action: UINT32,
    pub FileNameBuf: __IncompleteArrayField<WCHAR>,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_NOTIFY_INFO() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_NOTIFY_INFO>(),
        12usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_NOTIFY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_NOTIFY_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_NOTIFY_INFO))
    );
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_NOTIFY_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_Filter() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_NOTIFY_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Filter) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(Filter)
            )
        );
    }
    test_field_Filter();
    fn test_field_Action() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_NOTIFY_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Action) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(Action)
            )
        );
    }
    test_field_Action();
    fn test_field_FileNameBuf() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_NOTIFY_INFO>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileNameBuf) as usize - ptr as usize
            },
            12usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_NOTIFY_INFO),
            "::",
            stringify!(FileNameBuf)
            )
        );
    }
    test_field_FileNameBuf();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_FULL_CONTEXT {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_FULL_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_FULL_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_FULL_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT))
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_FULL_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_FULL_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_FULL_CONTEXT),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_BUF {
    pub Offset: UINT16,
    pub Size: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_BUF() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_BUF>(),
        4usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_BUF))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_BUF>(),
        2usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_BUF))
    );
    fn test_field_Offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_BUF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_BUF),
            "::",
            stringify!(Offset)
            )
        );
    }
    test_field_Offset();
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_BUF>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            2usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_BUF),
            "::",
            stringify!(Size)
            )
        );
    }
    test_field_Size();
}
#[repr(C)]
pub struct FSP_FSCTL_TRANSACT_REQ {
    pub Version: UINT16,
    pub Size: UINT16,
    pub Kind: UINT32,
    pub Hint: UINT64,
    pub Req: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1,
    pub FileName: FSP_FSCTL_TRANSACT_BUF,
    pub __bindgen_padding_0: [u8; 4usize],
    pub Buffer: __IncompleteArrayField<UINT8>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1 {
    pub Create: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
    pub Overwrite: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
    pub Cleanup: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3,
    pub Close: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4,
    pub Read: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
    pub Write: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
    pub QueryInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7,
    pub SetInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8,
    pub QueryEa: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9,
    pub SetEa: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10,
    pub FlushBuffers: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11,
    pub SetVolumeInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12,
    pub QueryDirectory: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
    pub FileSystemControl: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
    pub DeviceControl: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
    pub QuerySecurity: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16,
    pub SetSecurity: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17,
    pub QueryStreamInformation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1 {
    pub CreateOptions: UINT32,
    pub FileAttributes: UINT32,
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
    pub AllocationSize: UINT64,
    pub AccessToken: UINT64,
    pub DesiredAccess: UINT32,
    pub GrantedAccess: UINT32,
    pub ShareAccess: UINT32,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 7usize]>,
    pub NamedStream: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1>(),
        64usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_CreateOptions() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CreateOptions) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CreateOptions)
            )
        );
    }
    test_field_CreateOptions();
    fn test_field_FileAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileAttributes)
            )
        );
    }
    test_field_FileAttributes();
    fn test_field_SecurityDescriptor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SecurityDescriptor)
            )
        );
    }
    test_field_SecurityDescriptor();
    fn test_field_AllocationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AllocationSize)
            )
        );
    }
    test_field_AllocationSize();
    fn test_field_AccessToken() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AccessToken)
            )
        );
    }
    test_field_AccessToken();
    fn test_field_DesiredAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DesiredAccess) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(DesiredAccess)
            )
        );
    }
    test_field_DesiredAccess();
    fn test_field_GrantedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize
            },
            36usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(GrantedAccess)
            )
        );
    }
    test_field_GrantedAccess();
    fn test_field_ShareAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ShareAccess) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(ShareAccess)
            )
        );
    }
    test_field_ShareAccess();
    fn test_field_Ea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize
            },
            44usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Ea)
            )
        );
    }
    test_field_Ea();
    fn test_field_NamedStream() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NamedStream) as usize - ptr as usize
            },
            56usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(NamedStream)
            )
        );
    }
    test_field_NamedStream();
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn UserMode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserMode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasTraversePrivilege(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasTraversePrivilege(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasBackupPrivilege(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasBackupPrivilege(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasRestorePrivilege(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasRestorePrivilege(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn OpenTargetDirectory(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OpenTargetDirectory(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CaseSensitive(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitive(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasTrailingBackslash(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasTrailingBackslash(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AcceptsSecurityDescriptor(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AcceptsSecurityDescriptor(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EaIsReparsePoint(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EaIsReparsePoint(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UserMode: UINT32,
        HasTraversePrivilege: UINT32,
        HasBackupPrivilege: UINT32,
        HasRestorePrivilege: UINT32,
        OpenTargetDirectory: UINT32,
        CaseSensitive: UINT32,
        HasTrailingBackslash: UINT32,
        AcceptsSecurityDescriptor: UINT32,
        EaIsReparsePoint: UINT32,
        ReservedFlags: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 7usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 7usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UserMode: u32 = unsafe { ::std::mem::transmute(UserMode) };
            UserMode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HasTraversePrivilege: u32 = unsafe { ::std::mem::transmute(HasTraversePrivilege) };
            HasTraversePrivilege as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let HasBackupPrivilege: u32 = unsafe { ::std::mem::transmute(HasBackupPrivilege) };
            HasBackupPrivilege as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let HasRestorePrivilege: u32 = unsafe { ::std::mem::transmute(HasRestorePrivilege) };
            HasRestorePrivilege as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let OpenTargetDirectory: u32 = unsafe { ::std::mem::transmute(OpenTargetDirectory) };
            OpenTargetDirectory as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let CaseSensitive: u32 = unsafe { ::std::mem::transmute(CaseSensitive) };
            CaseSensitive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let HasTrailingBackslash: u32 = unsafe { ::std::mem::transmute(HasTrailingBackslash) };
            HasTrailingBackslash as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AcceptsSecurityDescriptor: u32 =
                unsafe { ::std::mem::transmute(AcceptsSecurityDescriptor) };
            AcceptsSecurityDescriptor as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EaIsReparsePoint: u32 = unsafe { ::std::mem::transmute(EaIsReparsePoint) };
            EaIsReparsePoint as u64
        });
        __bindgen_bitfield_unit.set(32usize, 24u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub FileAttributes: UINT32,
    pub AllocationSize: UINT64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: u16,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2>(),
        40usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_FileAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(FileAttributes)
            )
        );
    }
    test_field_FileAttributes();
    fn test_field_AllocationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(AllocationSize)
            )
        );
    }
    test_field_AllocationSize();
    fn test_field_Ea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize
            },
            36usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Ea)
            )
        );
    }
    test_field_Ea();
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn Supersede(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Supersede(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Supersede: UINT32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Supersede: u32 = unsafe { ::std::mem::transmute(Supersede) };
            Supersede as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3>(),
        24usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn Delete(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Delete(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetAllocationSize(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetAllocationSize(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetArchiveBit(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetArchiveBit(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetLastAccessTime(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetLastAccessTime(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetLastWriteTime(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetLastWriteTime(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SetChangeTime(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SetChangeTime(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Delete: UINT32,
        SetAllocationSize: UINT32,
        SetArchiveBit: UINT32,
        SetLastAccessTime: UINT32,
        SetLastWriteTime: UINT32,
        SetChangeTime: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Delete: u32 = unsafe { ::std::mem::transmute(Delete) };
            Delete as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SetAllocationSize: u32 = unsafe { ::std::mem::transmute(SetAllocationSize) };
            SetAllocationSize as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let SetArchiveBit: u32 = unsafe { ::std::mem::transmute(SetArchiveBit) };
            SetArchiveBit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SetLastAccessTime: u32 = unsafe { ::std::mem::transmute(SetLastAccessTime) };
            SetLastAccessTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SetLastWriteTime: u32 = unsafe { ::std::mem::transmute(SetLastWriteTime) };
            SetLastWriteTime as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let SetChangeTime: u32 = unsafe { ::std::mem::transmute(SetChangeTime) };
            SetChangeTime as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Address: UINT64,
    pub Offset: UINT64,
    pub Length: UINT32,
    pub Key: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5>(),
        40usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_Address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Address)
            )
        );
    }
    test_field_Address();
    fn test_field_Offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Offset)
            )
        );
    }
    test_field_Offset();
    fn test_field_Length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Length)
            )
        );
    }
    test_field_Length();
    fn test_field_Key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize
            },
            36usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(Key)
            )
        );
    }
    test_field_Key();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Address: UINT64,
    pub Offset: UINT64,
    pub Length: UINT32,
    pub Key: UINT32,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 7usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6>(),
        48usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_Address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Address)
            )
        );
    }
    test_field_Address();
    fn test_field_Offset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Offset) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Offset)
            )
        );
    }
    test_field_Offset();
    fn test_field_Length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Length)
            )
        );
    }
    test_field_Length();
    fn test_field_Key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Key) as usize - ptr as usize
            },
            36usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6),
            "::",
            stringify!(Key)
            )
        );
    }
    test_field_Key();
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_6 {
    #[inline]
    pub fn ConstrainedIo(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ConstrainedIo(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(ConstrainedIo: UINT32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ConstrainedIo: u32 = unsafe { ::std::mem::transmute(ConstrainedIo) };
            ConstrainedIo as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7>(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_7),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub FileInformationClass: UINT32,
    pub Info: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    pub Allocation: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
    pub Basic: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
    pub Disposition: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3,
    pub DispositionEx:
    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
    pub EndOfFile: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
    pub Rename: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
    pub RenameEx: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1 {
    pub AllocationSize: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    fn test_field_AllocationSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AllocationSize) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_1
                ),
            "::",
            stringify!(AllocationSize)
            )
        );
    }
    test_field_AllocationSize();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2 {
    pub FileAttributes: UINT32,
    pub CreationTime: UINT64,
    pub LastAccessTime: UINT64,
    pub LastWriteTime: UINT64,
    pub ChangeTime: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
        >(),
        40usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
        >(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
            )
        )
    );
    fn test_field_FileAttributes() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileAttributes) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
                ),
            "::",
            stringify!(FileAttributes)
            )
        );
    }
    test_field_FileAttributes();
    fn test_field_CreationTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CreationTime) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
                ),
            "::",
            stringify!(CreationTime)
            )
        );
    }
    test_field_CreationTime();
    fn test_field_LastAccessTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LastAccessTime) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
                ),
            "::",
            stringify!(LastAccessTime)
            )
        );
    }
    test_field_LastAccessTime();
    fn test_field_LastWriteTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LastWriteTime) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
                ),
            "::",
            stringify!(LastWriteTime)
            )
        );
    }
    test_field_LastWriteTime();
    fn test_field_ChangeTime() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ChangeTime) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_2
                ),
            "::",
            stringify!(ChangeTime)
            )
        );
    }
    test_field_ChangeTime();
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3,
        >(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3,
        >(),
        4usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3
            )
        )
    );
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_3 {
    #[inline]
    pub fn Delete(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Delete(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(Delete: UINT32) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Delete: u32 = unsafe { ::std::mem::transmute(Delete) };
            Delete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4 {
    pub Flags: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
        >(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
        >(),
        4usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4
            )
        )
    );
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_4
                ),
            "::",
            stringify!(Flags)
            )
        );
    }
    test_field_Flags();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5 {
    pub FileSize: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
        >(),
        8usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
        >(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5
            )
        )
    );
    fn test_field_FileSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileSize) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_5
                ),
            "::",
            stringify!(FileSize)
            )
        );
    }
    test_field_FileSize();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6 {
    pub NewFileName: FSP_FSCTL_TRANSACT_BUF,
    pub AccessToken: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
        >(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
        >(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
            )
        )
    );
    fn test_field_NewFileName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NewFileName) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
                ),
            "::",
            stringify!(NewFileName)
            )
        );
    }
    test_field_NewFileName();
    fn test_field_AccessToken() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_6
                ),
            "::",
            stringify!(AccessToken)
            )
        );
    }
    test_field_AccessToken();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7 {
    pub NewFileName: FSP_FSCTL_TRANSACT_BUF,
    pub AccessToken: UINT64,
    pub Flags: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
        >(),
        24usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
        >(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
            )
        )
    );
    fn test_field_NewFileName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NewFileName) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
                ),
            "::",
            stringify!(NewFileName)
            )
        );
    }
    test_field_NewFileName();
    fn test_field_AccessToken() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AccessToken) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
                ),
            "::",
            stringify!(AccessToken)
            )
        );
    }
    test_field_AccessToken();
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1__bindgen_ty_7
                ),
            "::",
            stringify!(Flags)
            )
        );
    }
    test_field_Flags();
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1>(),
        40usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1)
        )
    );
    fn test_field_Allocation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Allocation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Allocation)
            )
        );
    }
    test_field_Allocation();
    fn test_field_Basic() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Basic) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Basic)
            )
        );
    }
    test_field_Basic();
    fn test_field_Disposition() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Disposition) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Disposition)
            )
        );
    }
    test_field_Disposition();
    fn test_field_DispositionEx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DispositionEx) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(DispositionEx)
            )
        );
    }
    test_field_DispositionEx();
    fn test_field_EndOfFile() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EndOfFile) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(EndOfFile)
            )
        );
    }
    test_field_EndOfFile();
    fn test_field_Rename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Rename) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(Rename)
            )
        );
    }
    test_field_Rename();
    fn test_field_RenameEx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).RenameEx) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1),
            "::",
            stringify!(RenameEx)
            )
        );
    }
    test_field_RenameEx();
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8>(),
        64usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_FileInformationClass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInformationClass) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(FileInformationClass)
            )
        );
    }
    test_field_FileInformationClass();
    fn test_field_Info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Info) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8),
            "::",
            stringify!(Info)
            )
        );
    }
    test_field_Info();
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9>(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_9),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10>(),
        24usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_Ea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_10),
            "::",
            stringify!(Ea)
            )
        );
    }
    test_field_Ea();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11>(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_11),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12 {
    pub FsInformationClass: UINT32,
    pub Info: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    pub Label: FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1 {
    pub VolumeLabel: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
        >(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(
                FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    fn test_field_VolumeLabel() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeLabel) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1__bindgen_ty_1
                ),
            "::",
            stringify!(VolumeLabel)
            )
        );
    }
    test_field_VolumeLabel();
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1)
        )
    );
    fn test_field_Label() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Label) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1),
            "::",
            stringify!(Label)
            )
        );
    }
    test_field_Label();
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12>(),
        8usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12>(),
        4usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12)
        )
    );
    fn test_field_FsInformationClass() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FsInformationClass) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(FsInformationClass)
            )
        );
    }
    test_field_FsInformationClass();
    fn test_field_Info() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Info) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12),
            "::",
            stringify!(Info)
            )
        );
    }
    test_field_Info();
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_12 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub Address: UINT64,
    pub Length: UINT32,
    pub Pattern: FSP_FSCTL_TRANSACT_BUF,
    pub Marker: FSP_FSCTL_TRANSACT_BUF,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13>(),
        40usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_Address() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Address) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Address)
            )
        );
    }
    test_field_Address();
    fn test_field_Length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Length) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Length)
            )
        );
    }
    test_field_Length();
    fn test_field_Pattern() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Pattern) as usize - ptr as usize
            },
            28usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Pattern)
            )
        );
    }
    test_field_Pattern();
    fn test_field_Marker() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Marker) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13),
            "::",
            stringify!(Marker)
            )
        );
    }
    test_field_Marker();
}
impl FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_13 {
    #[inline]
    pub fn CaseSensitive(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CaseSensitive(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PatternIsFileName(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PatternIsFileName(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        CaseSensitive: UINT32,
        PatternIsFileName: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let CaseSensitive: u32 = unsafe { ::std::mem::transmute(CaseSensitive) };
            CaseSensitive as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let PatternIsFileName: u32 = unsafe { ::std::mem::transmute(PatternIsFileName) };
            PatternIsFileName as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub FsControlCode: UINT32,
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
    pub TargetOnFileSystem: UINT16,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14>(),
        32usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_FsControlCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FsControlCode) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(FsControlCode)
            )
        );
    }
    test_field_FsControlCode();
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
    fn test_field_TargetOnFileSystem() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).TargetOnFileSystem) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_14),
            "::",
            stringify!(TargetOnFileSystem)
            )
        );
    }
    test_field_TargetOnFileSystem();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub IoControlCode: UINT32,
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
    pub OutputLength: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15>(),
        32usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_IoControlCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IoControlCode) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(IoControlCode)
            )
        );
    }
    test_field_IoControlCode();
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
    fn test_field_OutputLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OutputLength) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_15),
            "::",
            stringify!(OutputLength)
            )
        );
    }
    test_field_OutputLength();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16>(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_16),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub SecurityInformation: UINT32,
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17>(),
        24usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_SecurityInformation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityInformation) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(SecurityInformation)
            )
        );
    }
    test_field_SecurityInformation();
    fn test_field_SecurityDescriptor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_17),
            "::",
            stringify!(SecurityDescriptor)
            )
        );
    }
    test_field_SecurityDescriptor();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18>(),
        16usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1__bindgen_ty_18),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>(),
        64usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1)
        )
    );
    fn test_field_Create() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Create) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Create)
            )
        );
    }
    test_field_Create();
    fn test_field_Overwrite() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Overwrite) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Overwrite)
            )
        );
    }
    test_field_Overwrite();
    fn test_field_Cleanup() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Cleanup) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Cleanup)
            )
        );
    }
    test_field_Cleanup();
    fn test_field_Close() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Close) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Close)
            )
        );
    }
    test_field_Close();
    fn test_field_Read() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Read) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Read)
            )
        );
    }
    test_field_Read();
    fn test_field_Write() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Write) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(Write)
            )
        );
    }
    test_field_Write();
    fn test_field_QueryInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryInformation)
            )
        );
    }
    test_field_QueryInformation();
    fn test_field_SetInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetInformation)
            )
        );
    }
    test_field_SetInformation();
    fn test_field_QueryEa() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryEa) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryEa)
            )
        );
    }
    test_field_QueryEa();
    fn test_field_SetEa() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetEa)
            )
        );
    }
    test_field_SetEa();
    fn test_field_FlushBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FlushBuffers) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(FlushBuffers)
            )
        );
    }
    test_field_FlushBuffers();
    fn test_field_SetVolumeInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetVolumeInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetVolumeInformation)
            )
        );
    }
    test_field_SetVolumeInformation();
    fn test_field_QueryDirectory() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryDirectory) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryDirectory)
            )
        );
    }
    test_field_QueryDirectory();
    fn test_field_FileSystemControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileSystemControl) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(FileSystemControl)
            )
        );
    }
    test_field_FileSystemControl();
    fn test_field_DeviceControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DeviceControl) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(DeviceControl)
            )
        );
    }
    test_field_DeviceControl();
    fn test_field_QuerySecurity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QuerySecurity) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QuerySecurity)
            )
        );
    }
    test_field_QuerySecurity();
    fn test_field_SetSecurity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(SetSecurity)
            )
        );
    }
    test_field_SetSecurity();
    fn test_field_QueryStreamInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryStreamInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1),
            "::",
            stringify!(QueryStreamInformation)
            )
        );
    }
    test_field_QueryStreamInformation();
}
impl Default for FSP_FSCTL_TRANSACT_REQ__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_REQ() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_REQ>(),
        88usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_REQ))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_REQ>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_REQ))
    );
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            2usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_Kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Kind)
            )
        );
    }
    test_field_Kind();
    fn test_field_Hint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Hint) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Hint)
            )
        );
    }
    test_field_Hint();
    fn test_field_Req() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Req) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Req)
            )
        );
    }
    test_field_Req();
    fn test_field_FileName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize
            },
            80usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(FileName)
            )
        );
    }
    test_field_FileName();
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_REQ>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            88usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_REQ),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
}
impl Default for FSP_FSCTL_TRANSACT_REQ {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
pub struct FSP_FSCTL_TRANSACT_RSP {
    pub Version: UINT16,
    pub Size: UINT16,
    pub Kind: UINT32,
    pub Hint: UINT64,
    pub IoStatus: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1,
    pub Rsp: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2,
    pub Buffer: __IncompleteArrayField<UINT8>,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1 {
    pub Information: UINT32,
    pub Status: UINT32,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1>(),
        8usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1>(),
        4usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1)
        )
    );
    fn test_field_Information() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Information) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1),
            "::",
            stringify!(Information)
            )
        );
    }
    test_field_Information();
    fn test_field_Status() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Status) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_1),
            "::",
            stringify!(Status)
            )
        );
    }
    test_field_Status();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2 {
    pub Create: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1,
    pub Overwrite: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2,
    pub Write: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3,
    pub QueryInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4,
    pub SetInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5,
    pub QueryEa: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6,
    pub SetEa: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7,
    pub FlushBuffers: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8,
    pub QueryVolumeInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9,
    pub SetVolumeInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10,
    pub FileSystemControl: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11,
    pub DeviceControl: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12,
    pub QuerySecurity: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13,
    pub SetSecurity: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14,
    pub QueryStreamInformation: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1 {
    pub Opened: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
    pub Reparse: FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    pub UserContext: UINT64,
    pub UserContext2: UINT64,
    pub GrantedAccess: UINT32,
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub FileName: FSP_FSCTL_TRANSACT_BUF,
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        104usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1)
        )
    );
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_UserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext2) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(UserContext2)
            )
        );
    }
    test_field_UserContext2();
    fn test_field_GrantedAccess() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GrantedAccess) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(GrantedAccess)
            )
        );
    }
    test_field_GrantedAccess();
    fn test_field_SecurityDescriptor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
            },
            20usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(SecurityDescriptor)
            )
        );
    }
    test_field_SecurityDescriptor();
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
    fn test_field_FileName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileName) as usize - ptr as usize
            },
            96usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(FileName)
            )
        );
    }
    test_field_FileName();
}
impl FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableCache(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableCache(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HasSecurityDescriptor(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HasSecurityDescriptor(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableCache: UINT32,
        HasSecurityDescriptor: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableCache: u32 = unsafe { ::std::mem::transmute(DisableCache) };
            DisableCache as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HasSecurityDescriptor: u32 =
                unsafe { ::std::mem::transmute(HasSecurityDescriptor) };
            HasSecurityDescriptor as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2)
        )
    );
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1>(),
        104usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1)
        )
    );
    fn test_field_Opened() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Opened) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Opened)
            )
        );
    }
    test_field_Opened();
    fn test_field_Reparse() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reparse) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Reparse)
            )
        );
    }
    test_field_Reparse();
}
impl Default for FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2>(),
        72usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2)
        )
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3>(),
        72usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3)
        )
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4>(),
        72usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4)
        )
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_4),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5>(),
        72usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5)
        )
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_5),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6 {
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6)
        )
    );
    fn test_field_Ea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_6),
            "::",
            stringify!(Ea)
            )
        );
    }
    test_field_Ea();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
    pub Ea: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7>(),
        80usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7)
        )
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
    fn test_field_Ea() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Ea) as usize - ptr as usize
            },
            72usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_7),
            "::",
            stringify!(Ea)
            )
        );
    }
    test_field_Ea();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8 {
    pub FileInfo: FSP_FSCTL_FILE_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8>(),
        72usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8)
        )
    );
    fn test_field_FileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_8),
            "::",
            stringify!(FileInfo)
            )
        );
    }
    test_field_FileInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9 {
    pub VolumeInfo: FSP_FSCTL_VOLUME_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9>(),
        88usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9)
        )
    );
    fn test_field_VolumeInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_9),
            "::",
            stringify!(VolumeInfo)
            )
        );
    }
    test_field_VolumeInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10 {
    pub VolumeInfo: FSP_FSCTL_VOLUME_INFO,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10>(),
        88usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10)
        )
    );
    fn test_field_VolumeInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_10),
            "::",
            stringify!(VolumeInfo)
            )
        );
    }
    test_field_VolumeInfo();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11)
        )
    );
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_11),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12)
        )
    );
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_12),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13 {
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13)
        )
    );
    fn test_field_SecurityDescriptor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_13),
            "::",
            stringify!(SecurityDescriptor)
            )
        );
    }
    test_field_SecurityDescriptor();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14 {
    pub SecurityDescriptor: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14)
        )
    );
    fn test_field_SecurityDescriptor() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SecurityDescriptor) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_14),
            "::",
            stringify!(SecurityDescriptor)
            )
        );
    }
    test_field_SecurityDescriptor();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15 {
    pub Buffer: FSP_FSCTL_TRANSACT_BUF,
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15>(),
        4usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15>(),
        2usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15)
        )
    );
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<
                    FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15,
                >::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2__bindgen_ty_15),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>(),
        104usize,
        concat!(
        "Size of: ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2)
        )
    );
    fn test_field_Create() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Create) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(Create)
            )
        );
    }
    test_field_Create();
    fn test_field_Overwrite() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Overwrite) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(Overwrite)
            )
        );
    }
    test_field_Overwrite();
    fn test_field_Write() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Write) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(Write)
            )
        );
    }
    test_field_Write();
    fn test_field_QueryInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryInformation)
            )
        );
    }
    test_field_QueryInformation();
    fn test_field_SetInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetInformation)
            )
        );
    }
    test_field_SetInformation();
    fn test_field_QueryEa() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryEa) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryEa)
            )
        );
    }
    test_field_QueryEa();
    fn test_field_SetEa() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetEa)
            )
        );
    }
    test_field_SetEa();
    fn test_field_FlushBuffers() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FlushBuffers) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(FlushBuffers)
            )
        );
    }
    test_field_FlushBuffers();
    fn test_field_QueryVolumeInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryVolumeInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryVolumeInformation)
            )
        );
    }
    test_field_QueryVolumeInformation();
    fn test_field_SetVolumeInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetVolumeInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetVolumeInformation)
            )
        );
    }
    test_field_SetVolumeInformation();
    fn test_field_FileSystemControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).FileSystemControl) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(FileSystemControl)
            )
        );
    }
    test_field_FileSystemControl();
    fn test_field_DeviceControl() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DeviceControl) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(DeviceControl)
            )
        );
    }
    test_field_DeviceControl();
    fn test_field_QuerySecurity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QuerySecurity) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QuerySecurity)
            )
        );
    }
    test_field_QuerySecurity();
    fn test_field_SetSecurity() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(SetSecurity)
            )
        );
    }
    test_field_SetSecurity();
    fn test_field_QueryStreamInformation() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).QueryStreamInformation) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2),
            "::",
            stringify!(QueryStreamInformation)
            )
        );
    }
    test_field_QueryStreamInformation();
}
impl Default for FSP_FSCTL_TRANSACT_RSP__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout_FSP_FSCTL_TRANSACT_RSP() {
    assert_eq!(
        ::std::mem::size_of::<FSP_FSCTL_TRANSACT_RSP>(),
        128usize,
        concat!("Size of: ", stringify!(FSP_FSCTL_TRANSACT_RSP))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_FSCTL_TRANSACT_RSP>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_FSCTL_TRANSACT_RSP))
    );
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_Size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Size) as usize - ptr as usize
            },
            2usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Size)
            )
        );
    }
    test_field_Size();
    fn test_field_Kind() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Kind) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Kind)
            )
        );
    }
    test_field_Kind();
    fn test_field_Hint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Hint) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Hint)
            )
        );
    }
    test_field_Hint();
    fn test_field_IoStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).IoStatus) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(IoStatus)
            )
        );
    }
    test_field_IoStatus();
    fn test_field_Rsp() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Rsp) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Rsp)
            )
        );
    }
    test_field_Rsp();
    fn test_field_Buffer() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_FSCTL_TRANSACT_RSP>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Buffer) as usize - ptr as usize
            },
            128usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_FSCTL_TRANSACT_RSP),
            "::",
            stringify!(Buffer)
            )
        );
    }
    test_field_Buffer();
}
impl Default for FSP_FSCTL_TRANSACT_RSP {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn FspFsctlCreateVolume(
        DevicePath: PWSTR,
        VolumeParams: *const FSP_FSCTL_VOLUME_PARAMS,
        VolumeNameBuf: PWCHAR,
        VolumeNameSize: SIZE_T,
        PVolumeHandle: PHANDLE,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlMakeMountdev(
        VolumeHandle: HANDLE,
        Persistent: BOOLEAN,
        UniqueId: *mut GUID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlTransact(
        VolumeHandle: HANDLE,
        ResponseBuf: PVOID,
        ResponseBufSize: SIZE_T,
        RequestBuf: PVOID,
        PRequestBufSize: *mut SIZE_T,
        Batch: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlStop(VolumeHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlStop0(VolumeHandle: HANDLE) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlNotify(
        VolumeHandle: HANDLE,
        NotifyInfo: *mut FSP_FSCTL_NOTIFY_INFO,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlGetVolumeList(
        DevicePath: PWSTR,
        VolumeListBuf: PWCHAR,
        PVolumeListSize: PSIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFsctlPreflight(DevicePath: PWSTR) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FSP_MOUNT_DESC {
    pub VolumeHandle: HANDLE,
    pub VolumeName: PWSTR,
    pub Security: PSECURITY_DESCRIPTOR,
    pub Reserved: UINT64,
    pub MountPoint: PWSTR,
    pub MountHandle: HANDLE,
}
#[test]
fn bindgen_test_layout_FSP_MOUNT_DESC() {
    assert_eq!(
        ::std::mem::size_of::<FSP_MOUNT_DESC>(),
        48usize,
        concat!("Size of: ", stringify!(FSP_MOUNT_DESC))
    );
    assert_eq!(
        ::std::mem::align_of::<FSP_MOUNT_DESC>(),
        8usize,
        concat!("Alignment of ", stringify!(FSP_MOUNT_DESC))
    );
    fn test_field_VolumeHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_MOUNT_DESC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeHandle) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(VolumeHandle)
            )
        );
    }
    test_field_VolumeHandle();
    fn test_field_VolumeName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_MOUNT_DESC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(VolumeName)
            )
        );
    }
    test_field_VolumeName();
    fn test_field_Security() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_MOUNT_DESC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Security) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(Security)
            )
        );
    }
    test_field_Security();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_MOUNT_DESC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
    fn test_field_MountPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_MOUNT_DESC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MountPoint) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(MountPoint)
            )
        );
    }
    test_field_MountPoint();
    fn test_field_MountHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<FSP_MOUNT_DESC>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MountHandle) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(FSP_MOUNT_DESC),
            "::",
            stringify!(MountHandle)
            )
        );
    }
    test_field_MountHandle();
}
impl Default for FSP_MOUNT_DESC {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn FspMountSet(Desc: *mut FSP_MOUNT_DESC) -> NTSTATUS;
}
extern "C" {
    pub fn FspMountRemove(Desc: *mut FSP_MOUNT_DESC) -> NTSTATUS;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FILE_FULL_EA_INFORMATION {
    pub NextEntryOffset: ULONG,
    pub Flags: UCHAR,
    pub EaNameLength: UCHAR,
    pub EaValueLength: USHORT,
    pub EaName: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_FULL_EA_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_FILE_FULL_EA_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_FULL_EA_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_FULL_EA_INFORMATION))
    );
    fn test_field_NextEntryOffset() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILE_FULL_EA_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).NextEntryOffset) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
            )
        );
    }
    test_field_NextEntryOffset();
    fn test_field_Flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILE_FULL_EA_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flags) as usize - ptr as usize
            },
            4usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(Flags)
            )
        );
    }
    test_field_Flags();
    fn test_field_EaNameLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILE_FULL_EA_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EaNameLength) as usize - ptr as usize
            },
            5usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaNameLength)
            )
        );
    }
    test_field_EaNameLength();
    fn test_field_EaValueLength() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILE_FULL_EA_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EaValueLength) as usize - ptr as usize
            },
            6usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaValueLength)
            )
        );
    }
    test_field_EaValueLength();
    fn test_field_EaName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FILE_FULL_EA_INFORMATION>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EaName) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_FILE_FULL_EA_INFORMATION),
            "::",
            stringify!(EaName)
            )
        );
    }
    test_field_EaName();
}
pub type PFILE_FULL_EA_INFORMATION = *mut _FILE_FULL_EA_INFORMATION;
#[doc = " @group File System"]
#[doc = ""]
#[doc = " A user mode file system is a program that uses the WinFsp API to expose a file system to"]
#[doc = " Windows. The user mode file system must implement the operations in FSP_FILE_SYSTEM_INTERFACE,"]
#[doc = " create a file system object using FspFileSystemCreate and start its dispatcher using"]
#[doc = " FspFileSystemStartDispatcher. At that point it will start receiving file system requests on the"]
#[doc = " FSP_FILE_SYSTEM_INTERFACE operations."]
pub type FSP_FILE_SYSTEM = _FSP_FILE_SYSTEM;
pub type FSP_FILE_SYSTEM_OPERATION_GUARD = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSP_FILE_SYSTEM,
        arg2: *mut FSP_FSCTL_TRANSACT_REQ,
        arg3: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS,
>;
pub type FSP_FILE_SYSTEM_OPERATION = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut FSP_FILE_SYSTEM,
        arg2: *mut FSP_FSCTL_TRANSACT_REQ,
        arg3: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS,
>;
pub const FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FINE:
FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY = 0;
pub const FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY_COARSE : FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY = 1 ;
#[doc = " User mode file system locking strategy."]
#[doc = ""]
#[doc = " Two concurrency models are provided:"]
#[doc = ""]
#[doc = " 1. A fine-grained concurrency model where file system NAMESPACE accesses"]
#[doc = " are guarded using an exclusive-shared (read-write) lock. File I/O is not"]
#[doc = " guarded and concurrent reads/writes/etc. are possible. [Note that the FSD"]
#[doc = " will still apply an exclusive-shared lock PER INDIVIDUAL FILE, but it will"]
#[doc = " not limit I/O operations for different files.]"]
#[doc = ""]
#[doc = " The fine-grained concurrency model applies the exclusive-shared lock as"]
#[doc = " follows:"]
#[doc = " <ul>"]
#[doc = " <li>EXCL: SetVolumeLabel, Flush(Volume),"]
#[doc = " Create, Cleanup(Delete), SetInformation(Rename)</li>"]
#[doc = " <li>SHRD: GetVolumeInfo, Open, SetInformation(Disposition), ReadDirectory</li>"]
#[doc = " <li>NONE: all other operations</li>"]
#[doc = " </ul>"]
#[doc = ""]
#[doc = " 2. A coarse-grained concurrency model where all file system accesses are"]
#[doc = " guarded by a mutually exclusive lock."]
#[doc = ""]
#[doc = " @see FspFileSystemSetOperationGuardStrategy"]
pub type FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY = ::std::os::raw::c_int;
pub const FspCleanupDelete: _bindgen_ty_7 = 1;
pub const FspCleanupSetAllocationSize: _bindgen_ty_7 = 2;
pub const FspCleanupSetArchiveBit: _bindgen_ty_7 = 16;
pub const FspCleanupSetLastAccessTime: _bindgen_ty_7 = 32;
pub const FspCleanupSetLastWriteTime: _bindgen_ty_7 = 64;
pub const FspCleanupSetChangeTime: _bindgen_ty_7 = 128;
pub type _bindgen_ty_7 = ::std::os::raw::c_int;
#[doc = " @class FSP_FILE_SYSTEM"]
#[doc = " File system interface."]
#[doc = ""]
#[doc = " The operations in this interface must be implemented by the user mode"]
#[doc = " file system. Not all operations need be implemented. For example,"]
#[doc = " a user mode file system that does not wish to support reparse points,"]
#[doc = " need not implement the reparse point operations."]
#[doc = ""]
#[doc = " Most of the operations accept a FileContext parameter. This parameter"]
#[doc = " has different meanings depending on the value of the FSP_FSCTL_VOLUME_PARAMS"]
#[doc = " flags UmFileContextIsUserContext2 and UmFileContextIsFullContext."]
#[doc = ""]
#[doc = " There are three cases to consider:"]
#[doc = " <ul>"]
#[doc = " <li>When both of these flags are unset (default), the FileContext parameter"]
#[doc = " represents the file node. The file node is a void pointer (or an integer"]
#[doc = " that can fit in a pointer) that is used to uniquely identify an open file."]
#[doc = " Opening the same file name should always yield the same file node value"]
#[doc = " for as long as the file with that name remains open anywhere in the system."]
#[doc = " </li>"]
#[doc = " <li>When the UmFileContextIsUserContext2 is set, the FileContext parameter"]
#[doc = " represents the file descriptor. The file descriptor is a void pointer (or"]
#[doc = " an integer that can fit in a pointer) that is used to identify an open"]
#[doc = " instance of a file. Opening the same file name may yield a different file"]
#[doc = " descriptor."]
#[doc = " </li>"]
#[doc = " <li>When the UmFileContextIsFullContext is set, the FileContext parameter"]
#[doc = " is a pointer to a FSP_FSCTL_TRANSACT_FULL_CONTEXT. This allows a user mode"]
#[doc = " file system to access the low-level UserContext and UserContext2 values."]
#[doc = " The UserContext is used to store the file node and the UserContext2 is"]
#[doc = " used to store the file descriptor for an open file."]
#[doc = " </li>"]
#[doc = " </ul>"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _FSP_FILE_SYSTEM_INTERFACE {
    #[doc = " Get volume information."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param VolumeInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the volume information on successful return"]
    #[doc = "     from this call."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub GetVolumeInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            VolumeInfo: *mut FSP_FSCTL_VOLUME_INFO,
        ) -> NTSTATUS,
    >,
    pub SetVolumeLabelW: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            VolumeLabel: PWSTR,
            VolumeInfo: *mut FSP_FSCTL_VOLUME_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Get file or directory attributes and security descriptor given a file name."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to get the attributes and security descriptor for."]
    #[doc = " @param PFileAttributes"]
    #[doc = "     Pointer to a memory location that will receive the file attributes on successful return"]
    #[doc = "     from this call. May be NULL."]
    #[doc = ""]
    #[doc = "     If this call returns STATUS_REPARSE, the file system MAY place here the index of the"]
    #[doc = "     first reparse point within FileName. The file system MAY also leave this at its default"]
    #[doc = "     value of 0."]
    #[doc = " @param SecurityDescriptor"]
    #[doc = "     Pointer to a buffer that will receive the file security descriptor on successful return"]
    #[doc = "     from this call. May be NULL."]
    #[doc = " @param PSecurityDescriptorSize [in,out]"]
    #[doc = "     Pointer to the security descriptor buffer size. On input it contains the size of the"]
    #[doc = "     security descriptor buffer. On output it will contain the actual size of the security"]
    #[doc = "     descriptor copied into the security descriptor buffer. May be NULL."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS, STATUS_REPARSE or error code."]
    #[doc = ""]
    #[doc = "     STATUS_REPARSE should be returned by file systems that support reparse points when"]
    #[doc = "     they encounter a FileName that contains reparse points anywhere but the final path"]
    #[doc = "     component."]
    pub GetSecurityByName: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            PFileAttributes: PUINT32,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            PSecurityDescriptorSize: *mut SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Create new file or directory."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to be created."]
    #[doc = " @param CreateOptions"]
    #[doc = "     Create options for this request. This parameter has the same meaning as the"]
    #[doc = "     CreateOptions parameter of the NtCreateFile API. User mode file systems should typically"]
    #[doc = "     only be concerned with the flag FILE_DIRECTORY_FILE, which is an instruction to create a"]
    #[doc = "     directory rather than a file. Some file systems may also want to pay attention to the"]
    #[doc = "     FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH flags, although these are"]
    #[doc = "     typically handled by the FSD component."]
    #[doc = " @param GrantedAccess"]
    #[doc = "     Determines the specific access rights that have been granted for this request. Upon"]
    #[doc = "     receiving this call all access checks have been performed and the user mode file system"]
    #[doc = "     need not perform any additional checks. However this parameter may be useful to a user"]
    #[doc = "     mode file system; for example the WinFsp-FUSE layer uses this parameter to determine"]
    #[doc = "     which flags to use in its POSIX open() call."]
    #[doc = " @param FileAttributes"]
    #[doc = "     File attributes to apply to the newly created file or directory."]
    #[doc = " @param SecurityDescriptor"]
    #[doc = "     Security descriptor to apply to the newly created file or directory. This security"]
    #[doc = "     descriptor will always be in self-relative format. Its length can be retrieved using the"]
    #[doc = "     Windows GetSecurityDescriptorLength API. Will be NULL for named streams."]
    #[doc = " @param AllocationSize"]
    #[doc = "     Allocation size for the newly created file."]
    #[doc = " @param PFileContext [out]"]
    #[doc = "     Pointer that will receive the file context on successful return from this call."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub Create: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            CreateOptions: UINT32,
            GrantedAccess: UINT32,
            FileAttributes: UINT32,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            AllocationSize: UINT64,
            PFileContext: *mut PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Open a file or directory."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to be opened."]
    #[doc = " @param CreateOptions"]
    #[doc = "     Create options for this request. This parameter has the same meaning as the"]
    #[doc = "     CreateOptions parameter of the NtCreateFile API. User mode file systems typically"]
    #[doc = "     do not need to do anything special with respect to this parameter. Some file systems may"]
    #[doc = "     also want to pay attention to the FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH"]
    #[doc = "     flags, although these are typically handled by the FSD component."]
    #[doc = " @param GrantedAccess"]
    #[doc = "     Determines the specific access rights that have been granted for this request. Upon"]
    #[doc = "     receiving this call all access checks have been performed and the user mode file system"]
    #[doc = "     need not perform any additional checks. However this parameter may be useful to a user"]
    #[doc = "     mode file system; for example the WinFsp-FUSE layer uses this parameter to determine"]
    #[doc = "     which flags to use in its POSIX open() call."]
    #[doc = " @param PFileContext [out]"]
    #[doc = "     Pointer that will receive the file context on successful return from this call."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub Open: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            CreateOptions: UINT32,
            GrantedAccess: UINT32,
            PFileContext: *mut PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Overwrite a file."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to overwrite."]
    #[doc = " @param FileAttributes"]
    #[doc = "     File attributes to apply to the overwritten file."]
    #[doc = " @param ReplaceFileAttributes"]
    #[doc = "     When TRUE the existing file attributes should be replaced with the new ones."]
    #[doc = "     When FALSE the existing file attributes should be merged (or'ed) with the new ones."]
    #[doc = " @param AllocationSize"]
    #[doc = "     Allocation size for the overwritten file."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub Overwrite: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileAttributes: UINT32,
            ReplaceFileAttributes: BOOLEAN,
            AllocationSize: UINT64,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Cleanup a file."]
    #[doc = ""]
    #[doc = " When CreateFile is used to open or create a file the kernel creates a kernel mode file"]
    #[doc = " object (type FILE_OBJECT) and a handle for it, which it returns to user-mode. The handle may"]
    #[doc = " be duplicated (using DuplicateHandle), but all duplicate handles always refer to the same"]
    #[doc = " file object. When all handles for a particular file object get closed (using CloseHandle)"]
    #[doc = " the system sends a Cleanup request to the file system."]
    #[doc = ""]
    #[doc = " There will be a Cleanup operation for every Create or Open operation posted to the user mode"]
    #[doc = " file system. However the Cleanup operation is <b>not</b> the final close operation on a file."]
    #[doc = " The file system must be ready to receive additional operations until close time. This is true"]
    #[doc = " even when the file is being deleted!"]
    #[doc = ""]
    #[doc = " The Flags parameter contains information about the cleanup operation:"]
    #[doc = " <ul>"]
    #[doc = " <li>FspCleanupDelete -"]
    #[doc = " An important function of the Cleanup operation is to complete a delete operation. Deleting"]
    #[doc = " a file or directory in Windows is a three-stage process where the file is first opened, then"]
    #[doc = " tested to see if the delete can proceed and if the answer is positive the file is then"]
    #[doc = " deleted during Cleanup."]
    #[doc = ""]
    #[doc = " If the file system supports POSIX unlink (FSP_FSCTL_VOLUME_PARAMS ::"]
    #[doc = " SupportsPosixUnlinkRename), then a Cleanup / FspCleanupDelete operation may arrive while"]
    #[doc = " there are other open file handles for this particular file node. If the file system does not"]
    #[doc = " support POSIX unlink, then a Cleanup / FspCleanupDelete operation will always be the last"]
    #[doc = " outstanding cleanup for this particular file node."]
    #[doc = " </li>"]
    #[doc = " <li>FspCleanupSetAllocationSize -"]
    #[doc = " The NTFS and FAT file systems reset a file's allocation size when they receive the last"]
    #[doc = " outstanding cleanup for a particular file node. User mode file systems that implement"]
    #[doc = " allocation size and wish to duplicate the NTFS and FAT behavior can use this flag."]
    #[doc = " </li>"]
    #[doc = " <li>"]
    #[doc = " FspCleanupSetArchiveBit -"]
    #[doc = " File systems that support the archive bit should set the file node's archive bit when this"]
    #[doc = " flag is set."]
    #[doc = " </li>"]
    #[doc = " <li>FspCleanupSetLastAccessTime, FspCleanupSetLastWriteTime, FspCleanupSetChangeTime - File"]
    #[doc = " systems should set the corresponding file time when each one of these flags is set. Note that"]
    #[doc = " updating the last access time is expensive and a file system may choose to not implement it."]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " There is no way to report failure of this operation. This is a Windows limitation."]
    #[doc = ""]
    #[doc = " As an optimization a file system may specify the FSP_FSCTL_VOLUME_PARAMS ::"]
    #[doc = " PostCleanupWhenModifiedOnly flag. In this case the FSD will only post Cleanup requests when"]
    #[doc = " the file was modified/deleted."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to cleanup."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to cleanup. Sent only when a Delete is requested."]
    #[doc = " @param Flags"]
    #[doc = "     These flags determine whether the file was modified and whether to delete the file."]
    #[doc = " @see"]
    #[doc = "     Close"]
    #[doc = "     CanDelete"]
    #[doc = "     SetDelete"]
    pub Cleanup: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Flags: ULONG,
        ),
    >,
    #[doc = " Close a file."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to be closed."]
    pub Close: ::std::option::Option<
        unsafe extern "C" fn(FileSystem: *mut FSP_FILE_SYSTEM, FileContext: PVOID),
    >,
    #[doc = " Read a file."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to be read."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the results of the read operation."]
    #[doc = " @param Offset"]
    #[doc = "     Offset within the file to read from."]
    #[doc = " @param Length"]
    #[doc = "     Length of data to read."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes read."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous"]
    #[doc = "     operation."]
    pub Read: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Buffer: PVOID,
            Offset: UINT64,
            Length: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Write a file."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to be written."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that contains the data to write."]
    #[doc = " @param Offset"]
    #[doc = "     Offset within the file to write to."]
    #[doc = " @param Length"]
    #[doc = "     Length of data to write."]
    #[doc = " @param WriteToEndOfFile"]
    #[doc = "     When TRUE the file system must write to the current end of file. In this case the Offset"]
    #[doc = "     parameter will contain the value -1."]
    #[doc = " @param ConstrainedIo"]
    #[doc = "     When TRUE the file system must not extend the file (i.e. change the file size)."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes written."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous"]
    #[doc = "     operation."]
    pub Write: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Buffer: PVOID,
            Offset: UINT64,
            Length: ULONG,
            WriteToEndOfFile: BOOLEAN,
            ConstrainedIo: BOOLEAN,
            PBytesTransferred: PULONG,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Flush a file or volume."]
    #[doc = ""]
    #[doc = " Note that the FSD will also flush all file/volume caches prior to invoking this operation."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to be flushed. When NULL the whole volume is being flushed."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc. Used when"]
    #[doc = "     flushing file (not volume)."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub Flush: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Get file or directory information."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to get information for."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub GetFileInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Set file or directory basic information."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to set information for."]
    #[doc = " @param FileAttributes"]
    #[doc = "     File attributes to apply to the file or directory. If the value INVALID_FILE_ATTRIBUTES"]
    #[doc = "     is sent, the file attributes should not be changed."]
    #[doc = " @param CreationTime"]
    #[doc = "     Creation time to apply to the file or directory. If the value 0 is sent, the creation"]
    #[doc = "     time should not be changed."]
    #[doc = " @param LastAccessTime"]
    #[doc = "     Last access time to apply to the file or directory. If the value 0 is sent, the last"]
    #[doc = "     access time should not be changed."]
    #[doc = " @param LastWriteTime"]
    #[doc = "     Last write time to apply to the file or directory. If the value 0 is sent, the last"]
    #[doc = "     write time should not be changed."]
    #[doc = " @param ChangeTime"]
    #[doc = "     Change time to apply to the file or directory. If the value 0 is sent, the change time"]
    #[doc = "     should not be changed."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub SetBasicInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileAttributes: UINT32,
            CreationTime: UINT64,
            LastAccessTime: UINT64,
            LastWriteTime: UINT64,
            ChangeTime: UINT64,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Set file/allocation size."]
    #[doc = ""]
    #[doc = " This function is used to change a file's sizes. Windows file systems maintain two kinds"]
    #[doc = " of sizes: the file size is where the End Of File (EOF) is, and the allocation size is the"]
    #[doc = " actual size that a file takes up on the \"disk\"."]
    #[doc = ""]
    #[doc = " The rules regarding file/allocation size are:"]
    #[doc = " <ul>"]
    #[doc = " <li>Allocation size must always be aligned to the allocation unit boundary. The allocation"]
    #[doc = " unit is the product <code>(UINT64)SectorSize * (UINT64)SectorsPerAllocationUnit</code> from"]
    #[doc = " the FSP_FSCTL_VOLUME_PARAMS structure. The FSD will always send properly aligned allocation"]
    #[doc = " sizes when setting the allocation size.</li>"]
    #[doc = " <li>Allocation size is always greater or equal to the file size.</li>"]
    #[doc = " <li>A file size of more than the current allocation size will also extend the allocation"]
    #[doc = " size to the next allocation unit boundary.</li>"]
    #[doc = " <li>An allocation size of less than the current file size should also truncate the current"]
    #[doc = " file size.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to set the file/allocation size for."]
    #[doc = " @param NewSize"]
    #[doc = "     New file/allocation size to apply to the file."]
    #[doc = " @param SetAllocationSize"]
    #[doc = "     If TRUE, then the allocation size is being set. if FALSE, then the file size is being set."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub SetFileSize: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            NewSize: UINT64,
            SetAllocationSize: BOOLEAN,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Determine whether a file or directory can be deleted."]
    #[doc = ""]
    #[doc = " This function tests whether a file or directory can be safely deleted. This function does"]
    #[doc = " not need to perform access checks, but may performs tasks such as check for empty"]
    #[doc = " directories, etc."]
    #[doc = ""]
    #[doc = " This function should <b>NEVER</b> delete the file or directory in question. Deletion should"]
    #[doc = " happen during Cleanup with the FspCleanupDelete flag set."]
    #[doc = ""]
    #[doc = " This function gets called when Win32 API's such as DeleteFile or RemoveDirectory are used."]
    #[doc = " It does not get called when a file or directory is opened with FILE_DELETE_ON_CLOSE."]
    #[doc = ""]
    #[doc = " NOTE: If both CanDelete and SetDelete are defined, SetDelete takes precedence. However"]
    #[doc = " most file systems need only implement the CanDelete operation."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to test for deletion."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to test for deletion."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     Cleanup"]
    #[doc = "     SetDelete"]
    pub CanDelete: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
        ) -> NTSTATUS,
    >,
    #[doc = " Renames a file or directory."]
    #[doc = ""]
    #[doc = " The kernel mode FSD provides certain guarantees prior to posting a rename operation:"]
    #[doc = " <ul>"]
    #[doc = " <li>A file cannot be renamed if a file with the same name exists and has open handles.</li>"]
    #[doc = " <li>A directory cannot be renamed if it or any of its subdirectories contains a file that"]
    #[doc = " has open handles.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to be renamed."]
    #[doc = " @param FileName"]
    #[doc = "     The current name of the file or directory to rename."]
    #[doc = " @param NewFileName"]
    #[doc = "     The new name for the file or directory."]
    #[doc = " @param ReplaceIfExists"]
    #[doc = "     Whether to replace a file that already exists at NewFileName."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub Rename: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            NewFileName: PWSTR,
            ReplaceIfExists: BOOLEAN,
        ) -> NTSTATUS,
    >,
    #[doc = " Get file or directory security descriptor."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to get the security descriptor for."]
    #[doc = " @param SecurityDescriptor"]
    #[doc = "     Pointer to a buffer that will receive the file security descriptor on successful return"]
    #[doc = "     from this call. May be NULL."]
    #[doc = " @param PSecurityDescriptorSize [in,out]"]
    #[doc = "     Pointer to the security descriptor buffer size. On input it contains the size of the"]
    #[doc = "     security descriptor buffer. On output it will contain the actual size of the security"]
    #[doc = "     descriptor copied into the security descriptor buffer. Cannot be NULL."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub GetSecurity: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            PSecurityDescriptorSize: *mut SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Set file or directory security descriptor."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to set the security descriptor for."]
    #[doc = " @param SecurityInformation"]
    #[doc = "     Describes what parts of the file or directory security descriptor should"]
    #[doc = "     be modified."]
    #[doc = " @param ModificationDescriptor"]
    #[doc = "     Describes the modifications to apply to the file or directory security descriptor."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     FspSetSecurityDescriptor"]
    #[doc = "     FspDeleteSecurityDescriptor"]
    pub SetSecurity: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            SecurityInformation: SECURITY_INFORMATION,
            ModificationDescriptor: PSECURITY_DESCRIPTOR,
        ) -> NTSTATUS,
    >,
    #[doc = " Read a directory."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the directory to be read."]
    #[doc = " @param Pattern"]
    #[doc = "     The pattern to match against files in this directory. Can be NULL. The file system"]
    #[doc = "     can choose to ignore this parameter as the FSD will always perform its own pattern"]
    #[doc = "     matching on the returned results."]
    #[doc = " @param Marker"]
    #[doc = "     A file name that marks where in the directory to start reading. Files with names"]
    #[doc = "     that are greater than (not equal to) this marker (in the directory order determined"]
    #[doc = "     by the file system) should be returned. Can be NULL."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the results of the read operation."]
    #[doc = " @param Length"]
    #[doc = "     Length of data to read."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes read."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code. STATUS_PENDING is supported allowing for asynchronous"]
    #[doc = "     operation."]
    #[doc = " @see"]
    #[doc = "     FspFileSystemAddDirInfo"]
    pub ReadDirectory: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Pattern: PWSTR,
            Marker: PWSTR,
            Buffer: PVOID,
            Length: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Resolve reparse points."]
    #[doc = ""]
    #[doc = " Reparse points are a general mechanism for attaching special behavior to files."]
    #[doc = " A file or directory can contain a reparse point. A reparse point is data that has"]
    #[doc = " special meaning to the file system, Windows or user applications. For example, NTFS"]
    #[doc = " and Windows use reparse points to implement symbolic links. As another example,"]
    #[doc = " a particular file system may use reparse points to emulate UNIX FIFO's."]
    #[doc = ""]
    #[doc = " This function is expected to resolve as many reparse points as possible. If a reparse"]
    #[doc = " point is encountered that is not understood by the file system further reparse point"]
    #[doc = " resolution should stop; the reparse point data should be returned to the FSD with status"]
    #[doc = " STATUS_REPARSE/reparse-tag. If a reparse point (symbolic link) is encountered that is"]
    #[doc = " understood by the file system but points outside it, the reparse point should be"]
    #[doc = " resolved, but further reparse point resolution should stop; the resolved file name"]
    #[doc = " should be returned to the FSD with status STATUS_REPARSE/IO_REPARSE."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to have its reparse points resolved."]
    #[doc = " @param ReparsePointIndex"]
    #[doc = "     The index of the first reparse point within FileName."]
    #[doc = " @param ResolveLastPathComponent"]
    #[doc = "     If FALSE, the last path component of FileName should not be resolved, even"]
    #[doc = "     if it is a reparse point that can be resolved. If TRUE, all path components"]
    #[doc = "     should be resolved if possible."]
    #[doc = " @param PIoStatus"]
    #[doc = "     Pointer to storage that will receive the status to return to the FSD. When"]
    #[doc = "     this function succeeds it must set PIoStatus->Status to STATUS_REPARSE and"]
    #[doc = "     PIoStatus->Information to either IO_REPARSE or the reparse tag."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the resolved file name (IO_REPARSE) or"]
    #[doc = "     reparse data (reparse tag). If the function returns a file name, it should"]
    #[doc = "     not be NULL terminated."]
    #[doc = " @param PSize [in,out]"]
    #[doc = "     Pointer to the buffer size. On input it contains the size of the buffer."]
    #[doc = "     On output it will contain the actual size of data copied."]
    #[doc = " @return"]
    #[doc = "     STATUS_REPARSE or error code."]
    pub ResolveReparsePoints: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            ReparsePointIndex: UINT32,
            ResolveLastPathComponent: BOOLEAN,
            PIoStatus: PIO_STATUS_BLOCK,
            Buffer: PVOID,
            PSize: PSIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Get reparse point."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the reparse point."]
    #[doc = " @param FileName"]
    #[doc = "     The file name of the reparse point."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the results of this operation. If"]
    #[doc = "     the function returns a symbolic link path, it should not be NULL terminated."]
    #[doc = " @param PSize [in,out]"]
    #[doc = "     Pointer to the buffer size. On input it contains the size of the buffer."]
    #[doc = "     On output it will contain the actual size of data copied."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     SetReparsePoint"]
    pub GetReparsePoint: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Buffer: PVOID,
            PSize: PSIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Set reparse point."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the reparse point."]
    #[doc = " @param FileName"]
    #[doc = "     The file name of the reparse point."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that contains the data for this operation. If this buffer"]
    #[doc = "     contains a symbolic link path, it should not be assumed to be NULL terminated."]
    #[doc = " @param Size"]
    #[doc = "     Size of data to write."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     GetReparsePoint"]
    pub SetReparsePoint: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Buffer: PVOID,
            Size: SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Delete reparse point."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the reparse point."]
    #[doc = " @param FileName"]
    #[doc = "     The file name of the reparse point."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that contains the data for this operation."]
    #[doc = " @param Size"]
    #[doc = "     Size of data to write."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub DeleteReparsePoint: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            Buffer: PVOID,
            Size: SIZE_T,
        ) -> NTSTATUS,
    >,
    #[doc = " Get named streams information."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to get stream information for."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the stream information."]
    #[doc = " @param Length"]
    #[doc = "     Length of buffer."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes stored."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     FspFileSystemAddStreamInfo"]
    pub GetStreamInfo: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Buffer: PVOID,
            Length: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Get directory information for a single file or directory within a parent directory."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the parent directory."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to get information for. This name is relative"]
    #[doc = "     to the parent directory and is a single path component."]
    #[doc = " @param DirInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the directory information on successful"]
    #[doc = "     return from this call. This information includes the file name, but also file"]
    #[doc = "     attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub GetDirInfoByName: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            DirInfo: *mut FSP_FSCTL_DIR_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Process control code."]
    #[doc = ""]
    #[doc = " This function is called when a program uses the DeviceIoControl API."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to be controled."]
    #[doc = " @param ControlCode"]
    #[doc = "     The control code for the operation. This code must have a DeviceType with bit"]
    #[doc = "     0x8000 set and must have a TransferType of METHOD_BUFFERED."]
    #[doc = " @param InputBuffer"]
    #[doc = "     Pointer to a buffer that contains the input data."]
    #[doc = " @param InputBufferLength"]
    #[doc = "     Input data length."]
    #[doc = " @param OutputBuffer"]
    #[doc = "     Pointer to a buffer that will receive the output data."]
    #[doc = " @param OutputBufferLength"]
    #[doc = "     Output data length."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes transferred."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub Control: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            ControlCode: UINT32,
            InputBuffer: PVOID,
            InputBufferLength: ULONG,
            OutputBuffer: PVOID,
            OutputBufferLength: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Set the file delete flag."]
    #[doc = ""]
    #[doc = " This function sets a flag to indicates whether the FSD file should delete a file"]
    #[doc = " when it is closed. This function does not need to perform access checks, but may"]
    #[doc = " performs tasks such as check for empty directories, etc."]
    #[doc = ""]
    #[doc = " This function should <b>NEVER</b> delete the file or directory in question. Deletion should"]
    #[doc = " happen during Cleanup with the FspCleanupDelete flag set."]
    #[doc = ""]
    #[doc = " This function gets called when Win32 API's such as DeleteFile or RemoveDirectory are used."]
    #[doc = " It does not get called when a file or directory is opened with FILE_DELETE_ON_CLOSE."]
    #[doc = ""]
    #[doc = " NOTE: If both CanDelete and SetDelete are defined, SetDelete takes precedence. However"]
    #[doc = " most file systems need only implement the CanDelete operation."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file or directory to set the delete flag for."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to set the delete flag for."]
    #[doc = " @param DeleteFile"]
    #[doc = "     If set to TRUE the FSD indicates that the file will be deleted on Cleanup; otherwise"]
    #[doc = "     it will not be deleted. It is legal to receive multiple SetDelete calls for the same"]
    #[doc = "     file with different DeleteFile parameters."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     Cleanup"]
    #[doc = "     CanDelete"]
    pub SetDelete: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileName: PWSTR,
            DeleteFileW: BOOLEAN,
        ) -> NTSTATUS,
    >,
    #[doc = " Create new file or directory."]
    #[doc = ""]
    #[doc = " This function works like Create, except that it also accepts an extra buffer that"]
    #[doc = " may contain extended attributes or a reparse point."]
    #[doc = ""]
    #[doc = " NOTE: If both Create and CreateEx are defined, CreateEx takes precedence."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to be created."]
    #[doc = " @param CreateOptions"]
    #[doc = "     Create options for this request. This parameter has the same meaning as the"]
    #[doc = "     CreateOptions parameter of the NtCreateFile API. User mode file systems should typically"]
    #[doc = "     only be concerned with the flag FILE_DIRECTORY_FILE, which is an instruction to create a"]
    #[doc = "     directory rather than a file. Some file systems may also want to pay attention to the"]
    #[doc = "     FILE_NO_INTERMEDIATE_BUFFERING and FILE_WRITE_THROUGH flags, although these are"]
    #[doc = "     typically handled by the FSD component."]
    #[doc = " @param GrantedAccess"]
    #[doc = "     Determines the specific access rights that have been granted for this request. Upon"]
    #[doc = "     receiving this call all access checks have been performed and the user mode file system"]
    #[doc = "     need not perform any additional checks. However this parameter may be useful to a user"]
    #[doc = "     mode file system; for example the WinFsp-FUSE layer uses this parameter to determine"]
    #[doc = "     which flags to use in its POSIX open() call."]
    #[doc = " @param FileAttributes"]
    #[doc = "     File attributes to apply to the newly created file or directory."]
    #[doc = " @param SecurityDescriptor"]
    #[doc = "     Security descriptor to apply to the newly created file or directory. This security"]
    #[doc = "     descriptor will always be in self-relative format. Its length can be retrieved using the"]
    #[doc = "     Windows GetSecurityDescriptorLength API. Will be NULL for named streams."]
    #[doc = " @param AllocationSize"]
    #[doc = "     Allocation size for the newly created file."]
    #[doc = " @param ExtraBuffer"]
    #[doc = "     Extended attributes or reparse point buffer."]
    #[doc = " @param ExtraLength"]
    #[doc = "     Extended attributes or reparse point buffer length."]
    #[doc = " @param ExtraBufferIsReparsePoint"]
    #[doc = "     FALSE: extra buffer is extended attributes; TRUE: extra buffer is reparse point."]
    #[doc = " @param PFileContext [out]"]
    #[doc = "     Pointer that will receive the file context on successful return from this call."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub CreateEx: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileName: PWSTR,
            CreateOptions: UINT32,
            GrantedAccess: UINT32,
            FileAttributes: UINT32,
            SecurityDescriptor: PSECURITY_DESCRIPTOR,
            AllocationSize: UINT64,
            ExtraBuffer: PVOID,
            ExtraLength: ULONG,
            ExtraBufferIsReparsePoint: BOOLEAN,
            PFileContext: *mut PVOID,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Overwrite a file."]
    #[doc = ""]
    #[doc = " This function works like Overwrite, except that it also accepts EA (extended attributes)."]
    #[doc = ""]
    #[doc = " NOTE: If both Overwrite and OverwriteEx are defined, OverwriteEx takes precedence."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to overwrite."]
    #[doc = " @param FileAttributes"]
    #[doc = "     File attributes to apply to the overwritten file."]
    #[doc = " @param ReplaceFileAttributes"]
    #[doc = "     When TRUE the existing file attributes should be replaced with the new ones."]
    #[doc = "     When FALSE the existing file attributes should be merged (or'ed) with the new ones."]
    #[doc = " @param AllocationSize"]
    #[doc = "     Allocation size for the overwritten file."]
    #[doc = " @param Ea"]
    #[doc = "     Extended attributes buffer."]
    #[doc = " @param EaLength"]
    #[doc = "     Extended attributes buffer length."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub OverwriteEx: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            FileAttributes: UINT32,
            ReplaceFileAttributes: BOOLEAN,
            AllocationSize: UINT64,
            Ea: PFILE_FULL_EA_INFORMATION,
            EaLength: ULONG,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    #[doc = " Get extended attributes."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to get extended attributes for."]
    #[doc = " @param Ea"]
    #[doc = "     Extended attributes buffer."]
    #[doc = " @param EaLength"]
    #[doc = "     Extended attributes buffer length."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes transferred."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     SetEa"]
    #[doc = "     FspFileSystemAddEa"]
    pub GetEa: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Ea: PFILE_FULL_EA_INFORMATION,
            EaLength: ULONG,
            PBytesTransferred: PULONG,
        ) -> NTSTATUS,
    >,
    #[doc = " Set extended attributes."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system on which this request is posted."]
    #[doc = " @param FileContext"]
    #[doc = "     The file context of the file to set extended attributes for."]
    #[doc = " @param Ea"]
    #[doc = "     Extended attributes buffer."]
    #[doc = " @param EaLength"]
    #[doc = "     Extended attributes buffer length."]
    #[doc = " @param FileInfo [out]"]
    #[doc = "     Pointer to a structure that will receive the file information on successful return"]
    #[doc = "     from this call. This information includes file attributes, file times, etc."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     GetEa"]
    pub SetEa: ::std::option::Option<
        unsafe extern "C" fn(
            FileSystem: *mut FSP_FILE_SYSTEM,
            FileContext: PVOID,
            Ea: PFILE_FULL_EA_INFORMATION,
            EaLength: ULONG,
            FileInfo: *mut FSP_FSCTL_FILE_INFO,
        ) -> NTSTATUS,
    >,
    pub Obsolete0: ::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>,
    pub Reserved: [::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>; 32usize],
}
#[test]
fn bindgen_test_layout__FSP_FILE_SYSTEM_INTERFACE() {
    assert_eq!(
        ::std::mem::size_of::<_FSP_FILE_SYSTEM_INTERFACE>(),
        512usize,
        concat!("Size of: ", stringify!(_FSP_FILE_SYSTEM_INTERFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_FILE_SYSTEM_INTERFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_FILE_SYSTEM_INTERFACE))
    );
    fn test_field_GetVolumeInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetVolumeInfo) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetVolumeInfo)
            )
        );
    }
    test_field_GetVolumeInfo();
    fn test_field_SetVolumeLabelW() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetVolumeLabelW) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetVolumeLabelW)
            )
        );
    }
    test_field_SetVolumeLabelW();
    fn test_field_GetSecurityByName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetSecurityByName) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetSecurityByName)
            )
        );
    }
    test_field_GetSecurityByName();
    fn test_field_Create() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Create) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Create)
            )
        );
    }
    test_field_Create();
    fn test_field_Open() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Open) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Open)
            )
        );
    }
    test_field_Open();
    fn test_field_Overwrite() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Overwrite) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Overwrite)
            )
        );
    }
    test_field_Overwrite();
    fn test_field_Cleanup() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Cleanup) as usize - ptr as usize
            },
            48usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Cleanup)
            )
        );
    }
    test_field_Cleanup();
    fn test_field_Close() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Close) as usize - ptr as usize
            },
            56usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Close)
            )
        );
    }
    test_field_Close();
    fn test_field_Read() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Read) as usize - ptr as usize
            },
            64usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Read)
            )
        );
    }
    test_field_Read();
    fn test_field_Write() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Write) as usize - ptr as usize
            },
            72usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Write)
            )
        );
    }
    test_field_Write();
    fn test_field_Flush() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Flush) as usize - ptr as usize
            },
            80usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Flush)
            )
        );
    }
    test_field_Flush();
    fn test_field_GetFileInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetFileInfo) as usize - ptr as usize
            },
            88usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetFileInfo)
            )
        );
    }
    test_field_GetFileInfo();
    fn test_field_SetBasicInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetBasicInfo) as usize - ptr as usize
            },
            96usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetBasicInfo)
            )
        );
    }
    test_field_SetBasicInfo();
    fn test_field_SetFileSize() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetFileSize) as usize - ptr as usize
            },
            104usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetFileSize)
            )
        );
    }
    test_field_SetFileSize();
    fn test_field_CanDelete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CanDelete) as usize - ptr as usize
            },
            112usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(CanDelete)
            )
        );
    }
    test_field_CanDelete();
    fn test_field_Rename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Rename) as usize - ptr as usize
            },
            120usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Rename)
            )
        );
    }
    test_field_Rename();
    fn test_field_GetSecurity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetSecurity) as usize - ptr as usize
            },
            128usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetSecurity)
            )
        );
    }
    test_field_GetSecurity();
    fn test_field_SetSecurity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetSecurity) as usize - ptr as usize
            },
            136usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetSecurity)
            )
        );
    }
    test_field_SetSecurity();
    fn test_field_ReadDirectory() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ReadDirectory) as usize - ptr as usize
            },
            144usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(ReadDirectory)
            )
        );
    }
    test_field_ReadDirectory();
    fn test_field_ResolveReparsePoints() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ResolveReparsePoints) as usize - ptr as usize
            },
            152usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(ResolveReparsePoints)
            )
        );
    }
    test_field_ResolveReparsePoints();
    fn test_field_GetReparsePoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetReparsePoint) as usize - ptr as usize
            },
            160usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetReparsePoint)
            )
        );
    }
    test_field_GetReparsePoint();
    fn test_field_SetReparsePoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetReparsePoint) as usize - ptr as usize
            },
            168usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetReparsePoint)
            )
        );
    }
    test_field_SetReparsePoint();
    fn test_field_DeleteReparsePoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DeleteReparsePoint) as usize - ptr as usize
            },
            176usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(DeleteReparsePoint)
            )
        );
    }
    test_field_DeleteReparsePoint();
    fn test_field_GetStreamInfo() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetStreamInfo) as usize - ptr as usize
            },
            184usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetStreamInfo)
            )
        );
    }
    test_field_GetStreamInfo();
    fn test_field_GetDirInfoByName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetDirInfoByName) as usize - ptr as usize
            },
            192usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetDirInfoByName)
            )
        );
    }
    test_field_GetDirInfoByName();
    fn test_field_Control() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Control) as usize - ptr as usize
            },
            200usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Control)
            )
        );
    }
    test_field_Control();
    fn test_field_SetDelete() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetDelete) as usize - ptr as usize
            },
            208usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetDelete)
            )
        );
    }
    test_field_SetDelete();
    fn test_field_CreateEx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).CreateEx) as usize - ptr as usize
            },
            216usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(CreateEx)
            )
        );
    }
    test_field_CreateEx();
    fn test_field_OverwriteEx() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OverwriteEx) as usize - ptr as usize
            },
            224usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(OverwriteEx)
            )
        );
    }
    test_field_OverwriteEx();
    fn test_field_GetEa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).GetEa) as usize - ptr as usize
            },
            232usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(GetEa)
            )
        );
    }
    test_field_GetEa();
    fn test_field_SetEa() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).SetEa) as usize - ptr as usize
            },
            240usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(SetEa)
            )
        );
    }
    test_field_SetEa();
    fn test_field_Obsolete0() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Obsolete0) as usize - ptr as usize
            },
            248usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Obsolete0)
            )
        );
    }
    test_field_Obsolete0();
    fn test_field_Reserved() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_INTERFACE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Reserved) as usize - ptr as usize
            },
            256usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_INTERFACE),
            "::",
            stringify!(Reserved)
            )
        );
    }
    test_field_Reserved();
}
#[doc = " @class FSP_FILE_SYSTEM"]
#[doc = " File system interface."]
#[doc = ""]
#[doc = " The operations in this interface must be implemented by the user mode"]
#[doc = " file system. Not all operations need be implemented. For example,"]
#[doc = " a user mode file system that does not wish to support reparse points,"]
#[doc = " need not implement the reparse point operations."]
#[doc = ""]
#[doc = " Most of the operations accept a FileContext parameter. This parameter"]
#[doc = " has different meanings depending on the value of the FSP_FSCTL_VOLUME_PARAMS"]
#[doc = " flags UmFileContextIsUserContext2 and UmFileContextIsFullContext."]
#[doc = ""]
#[doc = " There are three cases to consider:"]
#[doc = " <ul>"]
#[doc = " <li>When both of these flags are unset (default), the FileContext parameter"]
#[doc = " represents the file node. The file node is a void pointer (or an integer"]
#[doc = " that can fit in a pointer) that is used to uniquely identify an open file."]
#[doc = " Opening the same file name should always yield the same file node value"]
#[doc = " for as long as the file with that name remains open anywhere in the system."]
#[doc = " </li>"]
#[doc = " <li>When the UmFileContextIsUserContext2 is set, the FileContext parameter"]
#[doc = " represents the file descriptor. The file descriptor is a void pointer (or"]
#[doc = " an integer that can fit in a pointer) that is used to identify an open"]
#[doc = " instance of a file. Opening the same file name may yield a different file"]
#[doc = " descriptor."]
#[doc = " </li>"]
#[doc = " <li>When the UmFileContextIsFullContext is set, the FileContext parameter"]
#[doc = " is a pointer to a FSP_FSCTL_TRANSACT_FULL_CONTEXT. This allows a user mode"]
#[doc = " file system to access the low-level UserContext and UserContext2 values."]
#[doc = " The UserContext is used to store the file node and the UserContext2 is"]
#[doc = " used to store the file descriptor for an open file."]
#[doc = " </li>"]
#[doc = " </ul>"]
pub type FSP_FILE_SYSTEM_INTERFACE = _FSP_FILE_SYSTEM_INTERFACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSP_FILE_SYSTEM {
    pub Version: UINT16,
    pub UserContext: PVOID,
    pub VolumeName: [WCHAR; 256usize],
    pub VolumeHandle: HANDLE,
    pub EnterOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
    pub LeaveOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
    pub Operations: [FSP_FILE_SYSTEM_OPERATION; 22usize],
    pub Interface: *const FSP_FILE_SYSTEM_INTERFACE,
    pub DispatcherThread: HANDLE,
    pub DispatcherThreadCount: ULONG,
    pub DispatcherResult: NTSTATUS,
    pub MountPoint: PWSTR,
    pub MountHandle: HANDLE,
    pub DebugLog: UINT32,
    pub OpGuardStrategy: FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY,
    pub OpGuardLock: SRWLOCK,
    pub UmFileContextIsUserContext2: BOOLEAN,
    pub UmFileContextIsFullContext: BOOLEAN,
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout__FSP_FILE_SYSTEM() {
    assert_eq!(
        ::std::mem::size_of::<_FSP_FILE_SYSTEM>(),
        792usize,
        concat!("Size of: ", stringify!(_FSP_FILE_SYSTEM))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_FILE_SYSTEM>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_FILE_SYSTEM))
    );
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_VolumeName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeName) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(VolumeName)
            )
        );
    }
    test_field_VolumeName();
    fn test_field_VolumeHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).VolumeHandle) as usize - ptr as usize
            },
            528usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(VolumeHandle)
            )
        );
    }
    test_field_VolumeHandle();
    fn test_field_EnterOperation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).EnterOperation) as usize - ptr as usize
            },
            536usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(EnterOperation)
            )
        );
    }
    test_field_EnterOperation();
    fn test_field_LeaveOperation() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).LeaveOperation) as usize - ptr as usize
            },
            544usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(LeaveOperation)
            )
        );
    }
    test_field_LeaveOperation();
    fn test_field_Operations() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Operations) as usize - ptr as usize
            },
            552usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(Operations)
            )
        );
    }
    test_field_Operations();
    fn test_field_Interface() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Interface) as usize - ptr as usize
            },
            728usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(Interface)
            )
        );
    }
    test_field_Interface();
    fn test_field_DispatcherThread() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DispatcherThread) as usize - ptr as usize
            },
            736usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DispatcherThread)
            )
        );
    }
    test_field_DispatcherThread();
    fn test_field_DispatcherThreadCount() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DispatcherThreadCount) as usize - ptr as usize
            },
            744usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DispatcherThreadCount)
            )
        );
    }
    test_field_DispatcherThreadCount();
    fn test_field_DispatcherResult() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DispatcherResult) as usize - ptr as usize
            },
            748usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DispatcherResult)
            )
        );
    }
    test_field_DispatcherResult();
    fn test_field_MountPoint() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MountPoint) as usize - ptr as usize
            },
            752usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(MountPoint)
            )
        );
    }
    test_field_MountPoint();
    fn test_field_MountHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).MountHandle) as usize - ptr as usize
            },
            760usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(MountHandle)
            )
        );
    }
    test_field_MountHandle();
    fn test_field_DebugLog() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).DebugLog) as usize - ptr as usize
            },
            768usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(DebugLog)
            )
        );
    }
    test_field_DebugLog();
    fn test_field_OpGuardStrategy() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OpGuardStrategy) as usize - ptr as usize
            },
            772usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(OpGuardStrategy)
            )
        );
    }
    test_field_OpGuardStrategy();
    fn test_field_OpGuardLock() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OpGuardLock) as usize - ptr as usize
            },
            776usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(OpGuardLock)
            )
        );
    }
    test_field_OpGuardLock();
    fn test_field_UmFileContextIsUserContext2() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UmFileContextIsUserContext2) as usize - ptr as usize
            },
            784usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(UmFileContextIsUserContext2)
            )
        );
    }
    test_field_UmFileContextIsUserContext2();
    fn test_field_UmFileContextIsFullContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UmFileContextIsFullContext) as usize - ptr as usize
            },
            785usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM),
            "::",
            stringify!(UmFileContextIsFullContext)
            )
        );
    }
    test_field_UmFileContextIsFullContext();
}
impl Default for _FSP_FILE_SYSTEM {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl _FSP_FILE_SYSTEM {
    #[inline]
    pub fn UmNoReparsePointsDirCheck(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_UmNoReparsePointsDirCheck(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UmReservedFlags(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 15u8) as u16) }
    }
    #[inline]
    pub fn set_UmReservedFlags(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        UmNoReparsePointsDirCheck: UINT16,
        UmReservedFlags: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let UmNoReparsePointsDirCheck: u16 =
                unsafe { ::std::mem::transmute(UmNoReparsePointsDirCheck) };
            UmNoReparsePointsDirCheck as u64
        });
        __bindgen_bitfield_unit.set(1usize, 15u8, {
            let UmReservedFlags: u16 = unsafe { ::std::mem::transmute(UmReservedFlags) };
            UmReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FSP_FILE_SYSTEM_OPERATION_CONTEXT {
    pub Request: *mut FSP_FSCTL_TRANSACT_REQ,
    pub Response: *mut FSP_FSCTL_TRANSACT_RSP,
}
#[test]
fn bindgen_test_layout__FSP_FILE_SYSTEM_OPERATION_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_FSP_FILE_SYSTEM_OPERATION_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_FILE_SYSTEM_OPERATION_CONTEXT>(),
        8usize,
        concat!(
        "Alignment of ",
        stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT)
        )
    );
    fn test_field_Request() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_OPERATION_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Request) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT),
            "::",
            stringify!(Request)
            )
        );
    }
    test_field_Request();
    fn test_field_Response() {
        assert_eq!(
            unsafe {
                let uninit =
                    ::std::mem::MaybeUninit::<_FSP_FILE_SYSTEM_OPERATION_CONTEXT>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Response) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_FILE_SYSTEM_OPERATION_CONTEXT),
            "::",
            stringify!(Response)
            )
        );
    }
    test_field_Response();
}
impl Default for _FSP_FILE_SYSTEM_OPERATION_CONTEXT {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type FSP_FILE_SYSTEM_OPERATION_CONTEXT = _FSP_FILE_SYSTEM_OPERATION_CONTEXT;
extern "C" {
    #[doc = " Check whether creating a file system object is possible."]
    #[doc = ""]
    #[doc = " @param DevicePath"]
    #[doc = "     The name of the control device for this file system. This must be either"]
    #[doc = "     FSP_FSCTL_DISK_DEVICE_NAME or FSP_FSCTL_NET_DEVICE_NAME."]
    #[doc = " @param MountPoint"]
    #[doc = "     The mount point for the new file system. A value of NULL means that the file system should"]
    #[doc = "     use the next available drive letter counting downwards from Z: as its mount point."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemPreflight(DevicePath: PWSTR, MountPoint: PWSTR) -> NTSTATUS;
}
extern "C" {
    #[doc = " Create a file system object."]
    #[doc = ""]
    #[doc = " @param DevicePath"]
    #[doc = "     The name of the control device for this file system. This must be either"]
    #[doc = "     FSP_FSCTL_DISK_DEVICE_NAME or FSP_FSCTL_NET_DEVICE_NAME."]
    #[doc = " @param VolumeParams"]
    #[doc = "     Volume parameters for the newly created file system."]
    #[doc = " @param Interface"]
    #[doc = "     A pointer to the actual operations that actually implement this user mode file system."]
    #[doc = " @param PFileSystem [out]"]
    #[doc = "     Pointer that will receive the file system object created on successful return from this"]
    #[doc = "     call."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemCreate(
        DevicePath: PWSTR,
        VolumeParams: *const FSP_FSCTL_VOLUME_PARAMS,
        Interface: *const FSP_FILE_SYSTEM_INTERFACE,
        PFileSystem: *mut *mut FSP_FILE_SYSTEM,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Delete a file system object."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    pub fn FspFileSystemDelete(FileSystem: *mut FSP_FILE_SYSTEM);
}
extern "C" {
    #[doc = " Set the mount point for a file system."]
    #[doc = ""]
    #[doc = " This function supports drive letters (X:) or directories as mount points:"]
    #[doc = " <ul>"]
    #[doc = " <li>Drive letters: Refer to the documentation of the DefineDosDevice Windows API"]
    #[doc = " to better understand how they are created.</li>"]
    #[doc = " <li>Directories: They can be used as mount points for disk based file systems. They cannot"]
    #[doc = " be used for network file systems. This is a limitation that Windows imposes on junctions.</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param MountPoint"]
    #[doc = "     The mount point for the new file system. A value of NULL means that the file system should"]
    #[doc = "     use the next available drive letter counting downwards from Z: as its mount point."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemSetMountPoint(
        FileSystem: *mut FSP_FILE_SYSTEM,
        MountPoint: PWSTR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemSetMountPointEx(
        FileSystem: *mut FSP_FILE_SYSTEM,
        MountPoint: PWSTR,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Remove the mount point for a file system."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    pub fn FspFileSystemRemoveMountPoint(FileSystem: *mut FSP_FILE_SYSTEM);
}
extern "C" {
    #[doc = " Start the file system dispatcher."]
    #[doc = ""]
    #[doc = " The file system dispatcher is used to dispatch operations posted by the FSD to the user mode"]
    #[doc = " file system. Once this call starts executing the user mode file system will start receiving"]
    #[doc = " file system requests from the kernel."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param ThreadCount"]
    #[doc = "     The number of threads for the file system dispatcher. A value of 0 will create a default"]
    #[doc = "     number of threads and should be chosen in most cases."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemStartDispatcher(
        FileSystem: *mut FSP_FILE_SYSTEM,
        ThreadCount: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Stop the file system dispatcher."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    pub fn FspFileSystemStopDispatcher(FileSystem: *mut FSP_FILE_SYSTEM);
}
extern "C" {
    #[doc = " Send a response to the FSD."]
    #[doc = ""]
    #[doc = " This call is not required when the user mode file system performs synchronous processing of"]
    #[doc = " requests. It is possible however for the following FSP_FILE_SYSTEM_INTERFACE operations to be"]
    #[doc = " processed asynchronously:"]
    #[doc = " <ul>"]
    #[doc = " <li>Read</li>"]
    #[doc = " <li>Write</li>"]
    #[doc = " <li>ReadDirectory</li>"]
    #[doc = " </ul>"]
    #[doc = ""]
    #[doc = " These operations are allowed to return STATUS_PENDING to postpone sending a response to the FSD."]
    #[doc = " At a later time the file system can use FspFileSystemSendResponse to send the response."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param Response"]
    #[doc = "     The response buffer."]
    pub fn FspFileSystemSendResponse(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    );
}
extern "C" {
    #[doc = " Begin notifying Windows that the file system has file changes."]
    #[doc = ""]
    #[doc = " A file system that wishes to notify Windows about file changes must"]
    #[doc = " first issue an FspFileSystemBegin call, followed by 0 or more"]
    #[doc = " FspFileSystemNotify calls, followed by an FspFileSystemNotifyEnd call."]
    #[doc = ""]
    #[doc = " This operation blocks concurrent file rename operations. File rename"]
    #[doc = " operations may interfere with file notification, because a file being"]
    #[doc = " notified may also be concurrently renamed. After all file change"]
    #[doc = " notifications have been issued, you must make sure to call"]
    #[doc = " FspFileSystemNotifyEnd to allow file rename operations to proceed."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code. The error code STATUS_CANT_WAIT means that"]
    #[doc = "     a file rename operation is currently in progress and the operation must be"]
    #[doc = "     retried at a later time."]
    pub fn FspFileSystemNotifyBegin(FileSystem: *mut FSP_FILE_SYSTEM, Timeout: ULONG) -> NTSTATUS;
}
extern "C" {
    #[doc = " End notifying Windows that the file system has file changes."]
    #[doc = ""]
    #[doc = " A file system that wishes to notify Windows about file changes must"]
    #[doc = " first issue an FspFileSystemBegin call, followed by 0 or more"]
    #[doc = " FspFileSystemNotify calls, followed by an FspFileSystemNotifyEnd call."]
    #[doc = ""]
    #[doc = " This operation allows any blocked file rename operations to proceed."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemNotifyEnd(FileSystem: *mut FSP_FILE_SYSTEM) -> NTSTATUS;
}
extern "C" {
    #[doc = " Notify Windows that the file system has file changes."]
    #[doc = ""]
    #[doc = " A file system that wishes to notify Windows about file changes must"]
    #[doc = " first issue an FspFileSystemBegin call, followed by 0 or more"]
    #[doc = " FspFileSystemNotify calls, followed by an FspFileSystemNotifyEnd call."]
    #[doc = ""]
    #[doc = " Note that FspFileSystemNotify requires file names to be normalized. A"]
    #[doc = " normalized file name is one that contains the correct case of all characters"]
    #[doc = " in the file name."]
    #[doc = ""]
    #[doc = " For case-sensitive file systems all file names are normalized by definition."]
    #[doc = " For case-insensitive file systems that implement file name normalization,"]
    #[doc = " a normalized file name is the one that the file system specifies in the"]
    #[doc = " response to Create or Open (see also FspFileSystemGetOpenFileInfo). For"]
    #[doc = " case-insensitive file systems that do not implement file name normalization"]
    #[doc = " a normalized file name is the upper case version of the file name used"]
    #[doc = " to open the file."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param NotifyInfo"]
    #[doc = "     Buffer containing information about file changes."]
    #[doc = " @param Size"]
    #[doc = "     Size of buffer."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspFileSystemNotify(
        FileSystem: *mut FSP_FILE_SYSTEM,
        NotifyInfo: *mut FSP_FSCTL_NOTIFY_INFO,
        Size: SIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Get the current operation context."]
    #[doc = ""]
    #[doc = " This function may be used only when servicing one of the FSP_FILE_SYSTEM_INTERFACE operations."]
    #[doc = " The current operation context is stored in thread local storage. It allows access to the"]
    #[doc = " Request and Response associated with this operation."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     The current operation context."]
    pub fn FspFileSystemGetOperationContext() -> *mut FSP_FILE_SYSTEM_OPERATION_CONTEXT;
}
extern "C" {
    pub fn FspFileSystemMountPointF(FileSystem: *mut FSP_FILE_SYSTEM) -> PWSTR;
}
extern "C" {
    pub fn FspFileSystemEnterOperationF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemLeaveOperationF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemSetOperationGuardF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        EnterOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
        LeaveOperation: FSP_FILE_SYSTEM_OPERATION_GUARD,
    );
}
extern "C" {
    pub fn FspFileSystemSetOperationGuardStrategyF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        GuardStrategy: FSP_FILE_SYSTEM_OPERATION_GUARD_STRATEGY,
    );
}
extern "C" {
    pub fn FspFileSystemSetOperationF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Index: ULONG,
        Operation: FSP_FILE_SYSTEM_OPERATION,
    );
}
extern "C" {
    pub fn FspFileSystemGetDispatcherResultF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        PDispatcherResult: *mut NTSTATUS,
    );
}
extern "C" {
    pub fn FspFileSystemSetDispatcherResultF(
        FileSystem: *mut FSP_FILE_SYSTEM,
        DispatcherResult: NTSTATUS,
    );
}
extern "C" {
    pub fn FspFileSystemSetDebugLogF(FileSystem: *mut FSP_FILE_SYSTEM, DebugLog: UINT32);
}
extern "C" {
    pub fn FspFileSystemIsOperationCaseSensitiveF() -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemOperationProcessIdF() -> UINT32;
}
extern "C" {
    pub fn FspFileSystemOpEnter(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpLeave(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpCreate(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpOverwrite(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpCleanup(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpClose(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpRead(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpWrite(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryEa(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetEa(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpFlushBuffers(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryVolumeInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetVolumeInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryDirectory(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpFileSystemControl(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpDeviceControl(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQuerySecurity(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpSetSecurity(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspFileSystemOpQueryStreamInformation(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        Response: *mut FSP_FSCTL_TRANSACT_RSP,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Add directory information to a buffer."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the ReadDirectory operation."]
    #[doc = ""]
    #[doc = " @param DirInfo"]
    #[doc = "     The directory information to add. A value of NULL acts as an EOF marker for a ReadDirectory"]
    #[doc = "     operation."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the results of the read operation. This should contain"]
    #[doc = "     the same value passed to the ReadDirectory Buffer parameter."]
    #[doc = " @param Length"]
    #[doc = "     Length of data to read. This should contain the same value passed to the ReadDirectory"]
    #[doc = "     Length parameter."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes read. This should"]
    #[doc = "     contain the same value passed to the ReadDirectory PBytesTransferred parameter."]
    #[doc = "     FspFileSystemAddDirInfo uses the value pointed by this parameter to track how much of the"]
    #[doc = "     buffer has been used so far."]
    #[doc = " @return"]
    #[doc = "     TRUE if the directory information was added, FALSE if there was not enough space to add it."]
    #[doc = " @see"]
    #[doc = "     ReadDirectory"]
    pub fn FspFileSystemAddDirInfo(
        DirInfo: *mut FSP_FSCTL_DIR_INFO,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Find reparse point in file name."]
    #[doc = ""]
    #[doc = " Given a file name this function returns an index to the first path component that is a reparse"]
    #[doc = " point. The function will call the supplied GetReparsePointByName function for every path"]
    #[doc = " component until it finds a reparse point or the whole path is processed."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the GetSecurityByName operation in file systems"]
    #[doc = " that support reparse points."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param GetReparsePointByName"]
    #[doc = "     Pointer to function that can retrieve reparse point information by name. The"]
    #[doc = "     FspFileSystemFindReparsePoint will call this function with the Buffer and PSize"]
    #[doc = "     arguments set to NULL. The function should return STATUS_SUCCESS if the passed"]
    #[doc = "     FileName is a reparse point or STATUS_NOT_A_REPARSE_POINT (or other error code)"]
    #[doc = "     otherwise."]
    #[doc = " @param Context"]
    #[doc = "     User context to supply to GetReparsePointByName."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory."]
    #[doc = " @param PReparsePointIndex"]
    #[doc = "     Pointer to a memory location that will receive the index of the first reparse point"]
    #[doc = "     within FileName. A value is only placed in this memory location if the function returns"]
    #[doc = "     TRUE. May be NULL."]
    #[doc = " @return"]
    #[doc = "     TRUE if a reparse point was found, FALSE otherwise."]
    #[doc = " @see"]
    #[doc = "     GetSecurityByName"]
    pub fn FspFileSystemFindReparsePoint(
        FileSystem: *mut FSP_FILE_SYSTEM,
        GetReparsePointByName: ::std::option::Option<
            unsafe extern "C" fn(
                FileSystem: *mut FSP_FILE_SYSTEM,
                Context: PVOID,
                FileName: PWSTR,
                IsDirectory: BOOLEAN,
                Buffer: PVOID,
                PSize: PSIZE_T,
            ) -> NTSTATUS,
        >,
        Context: PVOID,
        FileName: PWSTR,
        PReparsePointIndex: PUINT32,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Resolve reparse points."]
    #[doc = ""]
    #[doc = " Given a file name (and an index where to start resolving) this function will attempt to"]
    #[doc = " resolve as many reparse points as possible. The function will call the supplied"]
    #[doc = " GetReparsePointByName function for every path component until it resolves the reparse points"]
    #[doc = " or the whole path is processed."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the ResolveReparsePoints operation in file systems"]
    #[doc = " that support reparse points."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param GetReparsePointByName"]
    #[doc = "     Pointer to function that can retrieve reparse point information by name. The function"]
    #[doc = "     should return STATUS_SUCCESS if the passed FileName is a reparse point or"]
    #[doc = "     STATUS_NOT_A_REPARSE_POINT (or other error code) otherwise."]
    #[doc = " @param Context"]
    #[doc = "     User context to supply to GetReparsePointByName."]
    #[doc = " @param FileName"]
    #[doc = "     The name of the file or directory to have its reparse points resolved."]
    #[doc = " @param ReparsePointIndex"]
    #[doc = "     The index of the first reparse point within FileName."]
    #[doc = " @param ResolveLastPathComponent"]
    #[doc = "     If FALSE, the last path component of FileName should not be resolved, even"]
    #[doc = "     if it is a reparse point that can be resolved. If TRUE, all path components"]
    #[doc = "     should be resolved if possible."]
    #[doc = " @param PIoStatus"]
    #[doc = "     Pointer to storage that will receive the status to return to the FSD. When"]
    #[doc = "     this function succeeds it must set PIoStatus->Status to STATUS_REPARSE and"]
    #[doc = "     PIoStatus->Information to either IO_REPARSE or the reparse tag."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the resolved file name (IO_REPARSE) or"]
    #[doc = "     reparse data (reparse tag). If the function returns a file name, it should"]
    #[doc = "     not be NULL terminated."]
    #[doc = " @param PSize [in,out]"]
    #[doc = "     Pointer to the buffer size. On input it contains the size of the buffer."]
    #[doc = "     On output it will contain the actual size of data copied."]
    #[doc = " @return"]
    #[doc = "     STATUS_REPARSE or error code."]
    #[doc = " @see"]
    #[doc = "     ResolveReparsePoints"]
    pub fn FspFileSystemResolveReparsePoints(
        FileSystem: *mut FSP_FILE_SYSTEM,
        GetReparsePointByName: ::std::option::Option<
            unsafe extern "C" fn(
                FileSystem: *mut FSP_FILE_SYSTEM,
                Context: PVOID,
                FileName: PWSTR,
                IsDirectory: BOOLEAN,
                Buffer: PVOID,
                PSize: PSIZE_T,
            ) -> NTSTATUS,
        >,
        Context: PVOID,
        FileName: PWSTR,
        ReparsePointIndex: UINT32,
        ResolveLastPathComponent: BOOLEAN,
        PIoStatus: PIO_STATUS_BLOCK,
        Buffer: PVOID,
        PSize: PSIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Test whether reparse data can be replaced."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the SetReparsePoint/DeleteReparsePoint operation"]
    #[doc = " in file systems that support reparse points."]
    #[doc = ""]
    #[doc = " @param CurrentReparseData"]
    #[doc = "     Pointer to the current reparse data."]
    #[doc = " @param CurrentReparseDataSize"]
    #[doc = "     Pointer to the current reparse data size."]
    #[doc = " @param ReplaceReparseData"]
    #[doc = "     Pointer to the replacement reparse data."]
    #[doc = " @param ReplaceReparseDataSize"]
    #[doc = "     Pointer to the replacement reparse data size."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     SetReparsePoint"]
    #[doc = "     DeleteReparsePoint"]
    pub fn FspFileSystemCanReplaceReparsePoint(
        CurrentReparseData: PVOID,
        CurrentReparseDataSize: SIZE_T,
        ReplaceReparseData: PVOID,
        ReplaceReparseDataSize: SIZE_T,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Add named stream information to a buffer."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the GetStreamInfo operation."]
    #[doc = ""]
    #[doc = " @param StreamInfo"]
    #[doc = "     The stream information to add. A value of NULL acts as an EOF marker for a GetStreamInfo"]
    #[doc = "     operation."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the stream information. This should contain"]
    #[doc = "     the same value passed to the GetStreamInfo Buffer parameter."]
    #[doc = " @param Length"]
    #[doc = "     Length of buffer. This should contain the same value passed to the GetStreamInfo"]
    #[doc = "     Length parameter."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes stored. This should"]
    #[doc = "     contain the same value passed to the GetStreamInfo PBytesTransferred parameter."]
    #[doc = " @return"]
    #[doc = "     TRUE if the stream information was added, FALSE if there was not enough space to add it."]
    #[doc = " @see"]
    #[doc = "     GetStreamInfo"]
    pub fn FspFileSystemAddStreamInfo(
        StreamInfo: *mut FSP_FSCTL_STREAM_INFO,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Enumerate extended attributes in a buffer."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the CreateEx and SetEa operations in file systems"]
    #[doc = " that support extended attributes."]
    #[doc = ""]
    #[doc = " @param FileSystem"]
    #[doc = "     The file system object."]
    #[doc = " @param EnumerateEa"]
    #[doc = "     Pointer to function that receives a single extended attribute. The function"]
    #[doc = "     should return STATUS_SUCCESS or an error code if unsuccessful."]
    #[doc = " @param Context"]
    #[doc = "     User context to supply to EnumEa."]
    #[doc = " @param Ea"]
    #[doc = "     Extended attributes buffer."]
    #[doc = " @param EaLength"]
    #[doc = "     Extended attributes buffer length."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code from EnumerateEa."]
    pub fn FspFileSystemEnumerateEa(
        FileSystem: *mut FSP_FILE_SYSTEM,
        EnumerateEa: ::std::option::Option<
            unsafe extern "C" fn(
                FileSystem: *mut FSP_FILE_SYSTEM,
                Context: PVOID,
                SingleEa: PFILE_FULL_EA_INFORMATION,
            ) -> NTSTATUS,
        >,
        Context: PVOID,
        Ea: PFILE_FULL_EA_INFORMATION,
        EaLength: ULONG,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Add extended attribute to a buffer."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the GetEa operation."]
    #[doc = ""]
    #[doc = " @param SingleEa"]
    #[doc = "     The extended attribute to add. A value of NULL acts as an EOF marker for a GetEa"]
    #[doc = "     operation."]
    #[doc = " @param Ea"]
    #[doc = "     Pointer to a buffer that will receive the extended attribute. This should contain"]
    #[doc = "     the same value passed to the GetEa Ea parameter."]
    #[doc = " @param EaLength"]
    #[doc = "     Length of buffer. This should contain the same value passed to the GetEa"]
    #[doc = "     EaLength parameter."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes stored. This should"]
    #[doc = "     contain the same value passed to the GetEa PBytesTransferred parameter."]
    #[doc = " @return"]
    #[doc = "     TRUE if the extended attribute was added, FALSE if there was not enough space to add it."]
    #[doc = " @see"]
    #[doc = "     GetEa"]
    pub fn FspFileSystemAddEa(
        SingleEa: PFILE_FULL_EA_INFORMATION,
        Ea: PFILE_FULL_EA_INFORMATION,
        EaLength: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    #[doc = " Add notify information to a buffer."]
    #[doc = ""]
    #[doc = " This is a helper for filling a buffer to use with FspFileSystemNotify."]
    #[doc = ""]
    #[doc = " @param NotifyInfo"]
    #[doc = "     The notify information to add."]
    #[doc = " @param Buffer"]
    #[doc = "     Pointer to a buffer that will receive the notify information."]
    #[doc = " @param Length"]
    #[doc = "     Length of buffer."]
    #[doc = " @param PBytesTransferred [out]"]
    #[doc = "     Pointer to a memory location that will receive the actual number of bytes stored. This should"]
    #[doc = "     be initialized to 0 prior to the first call to FspFileSystemAddNotifyInfo for a particular"]
    #[doc = "     buffer."]
    #[doc = " @return"]
    #[doc = "     TRUE if the notify information was added, FALSE if there was not enough space to add it."]
    #[doc = " @see"]
    #[doc = "     FspFileSystemNotify"]
    pub fn FspFileSystemAddNotifyInfo(
        NotifyInfo: *mut FSP_FSCTL_NOTIFY_INFO,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemAcquireDirectoryBufferEx(
        PDirBuffer: *mut PVOID,
        Reset: BOOLEAN,
        CapacityHint: ULONG,
        PResult: PNTSTATUS,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemAcquireDirectoryBuffer(
        PDirBuffer: *mut PVOID,
        Reset: BOOLEAN,
        PResult: PNTSTATUS,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemFillDirectoryBuffer(
        PDirBuffer: *mut PVOID,
        DirInfo: *mut FSP_FSCTL_DIR_INFO,
        PResult: PNTSTATUS,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn FspFileSystemReleaseDirectoryBuffer(PDirBuffer: *mut PVOID);
}
extern "C" {
    pub fn FspFileSystemReadDirectoryBuffer(
        PDirBuffer: *mut PVOID,
        Marker: PWSTR,
        Buffer: PVOID,
        Length: ULONG,
        PBytesTransferred: PULONG,
    );
}
extern "C" {
    pub fn FspFileSystemDeleteDirectoryBuffer(PDirBuffer: *mut PVOID);
}
extern "C" {
    pub fn FspGetFileGenericMapping() -> PGENERIC_MAPPING;
}
extern "C" {
    pub fn FspAccessCheckEx(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        CheckParentOrMain: BOOLEAN,
        AllowTraverseCheck: BOOLEAN,
        DesiredAccess: UINT32,
        PGrantedAccess: PUINT32,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspCreateSecurityDescriptor(
        FileSystem: *mut FSP_FILE_SYSTEM,
        Request: *mut FSP_FSCTL_TRANSACT_REQ,
        ParentDescriptor: PSECURITY_DESCRIPTOR,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Modify security descriptor."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the SetSecurity operation."]
    #[doc = ""]
    #[doc = " @param InputDescriptor"]
    #[doc = "     The input security descriptor to be modified."]
    #[doc = " @param SecurityInformation"]
    #[doc = "     Describes what parts of the InputDescriptor should be modified. This should contain"]
    #[doc = "     the same value passed to the SetSecurity SecurityInformation parameter."]
    #[doc = " @param ModificationDescriptor"]
    #[doc = "     Describes the modifications to apply to the InputDescriptor. This should contain"]
    #[doc = "     the same value passed to the SetSecurity ModificationDescriptor parameter."]
    #[doc = " @param PSecurityDescriptor [out]"]
    #[doc = "     Pointer to a memory location that will receive the resulting security descriptor."]
    #[doc = "     This security descriptor can be later freed using FspDeleteSecurityDescriptor."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     SetSecurity"]
    #[doc = "     FspDeleteSecurityDescriptor"]
    pub fn FspSetSecurityDescriptor(
        InputDescriptor: PSECURITY_DESCRIPTOR,
        SecurityInformation: SECURITY_INFORMATION,
        ModificationDescriptor: PSECURITY_DESCRIPTOR,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Delete security descriptor."]
    #[doc = ""]
    #[doc = " This is a helper for implementing the SetSecurity operation."]
    #[doc = ""]
    #[doc = " @param SecurityDescriptor"]
    #[doc = "     The security descriptor to be deleted."]
    #[doc = " @param CreateFunc"]
    #[doc = "     Function used to create the security descriptor. This parameter should be"]
    #[doc = "     set to FspSetSecurityDescriptor for the public API."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    #[doc = " @see"]
    #[doc = "     SetSecurity"]
    #[doc = "     FspSetSecurityDescriptor"]
    pub fn FspDeleteSecurityDescriptor(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        CreateFunc: ::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>,
    );
}
extern "C" {
    pub fn FspPosixSetUidMap(Uid: *mut UINT32, Sid: *mut PSID, Count: ULONG) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapUidToSid(Uid: UINT32, PSid: *mut PSID) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapSidToUid(Sid: PSID, PUid: PUINT32) -> NTSTATUS;
}
extern "C" {
    pub fn FspDeleteSid(
        Sid: PSID,
        CreateFunc: ::std::option::Option<unsafe extern "C" fn() -> NTSTATUS>,
    );
}
extern "C" {
    pub fn FspPosixMapPermissionsToSecurityDescriptor(
        Uid: UINT32,
        Gid: UINT32,
        Mode: UINT32,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMergePermissionsToSecurityDescriptor(
        Uid: UINT32,
        Gid: UINT32,
        Mode: UINT32,
        ExistingSecurityDescriptor: PSECURITY_DESCRIPTOR,
        PSecurityDescriptor: *mut PSECURITY_DESCRIPTOR,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapSecurityDescriptorToPermissions(
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
        PUid: PUINT32,
        PGid: PUINT32,
        PMode: PUINT32,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapWindowsToPosixPathEx(
        WindowsPath: PWSTR,
        PPosixPath: *mut *mut ::std::os::raw::c_char,
        Translate: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixMapPosixToWindowsPathEx(
        PosixPath: *const ::std::os::raw::c_char,
        PWindowsPath: *mut PWSTR,
        Translate: BOOLEAN,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspPosixDeletePath(Path: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn FspPosixEncodeWindowsPath(WindowsPath: PWSTR, Size: ULONG);
}
extern "C" {
    pub fn FspPosixDecodeWindowsPath(WindowsPath: PWSTR, Size: ULONG);
}
extern "C" {
    pub fn FspPathPrefix(Path: PWSTR, PPrefix: *mut PWSTR, PRemain: *mut PWSTR, Root: PWSTR);
}
extern "C" {
    pub fn FspPathSuffix(Path: PWSTR, PRemain: *mut PWSTR, PSuffix: *mut PWSTR, Root: PWSTR);
}
extern "C" {
    pub fn FspPathCombine(Prefix: PWSTR, Suffix: PWSTR);
}
#[doc = " @group Service Framework"]
#[doc = ""]
#[doc = " User mode file systems typically are run as Windows services. WinFsp provides an API to make"]
#[doc = " the creation of Windows services easier. This API is provided for convenience and is not"]
#[doc = " necessary to expose a user mode file system to Windows."]
pub type FSP_SERVICE = _FSP_SERVICE;
pub type FSP_SERVICE_START = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut FSP_SERVICE, arg2: ULONG, arg3: *mut PWSTR) -> NTSTATUS,
>;
pub type FSP_SERVICE_STOP =
::std::option::Option<unsafe extern "C" fn(arg1: *mut FSP_SERVICE) -> NTSTATUS>;
pub type FSP_SERVICE_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut FSP_SERVICE, arg2: ULONG, arg3: ULONG, arg4: PVOID) -> NTSTATUS,
>;
#[repr(C)]
#[derive(Debug)]
pub struct _FSP_SERVICE {
    pub Version: UINT16,
    pub UserContext: PVOID,
    pub OnStart: FSP_SERVICE_START,
    pub OnStop: FSP_SERVICE_STOP,
    pub OnControl: FSP_SERVICE_CONTROL,
    pub AcceptControl: ULONG,
    pub ExitCode: ULONG,
    pub StatusHandle: SERVICE_STATUS_HANDLE,
    pub ServiceStatus: SERVICE_STATUS,
    pub ServiceStatusGuard: CRITICAL_SECTION,
    pub ServiceStopGuard: CRITICAL_SECTION,
    pub AllowConsoleMode: BOOLEAN,
    pub ServiceName: __IncompleteArrayField<WCHAR>,
}
#[test]
fn bindgen_test_layout__FSP_SERVICE() {
    assert_eq!(
        ::std::mem::size_of::<_FSP_SERVICE>(),
        176usize,
        concat!("Size of: ", stringify!(_FSP_SERVICE))
    );
    assert_eq!(
        ::std::mem::align_of::<_FSP_SERVICE>(),
        8usize,
        concat!("Alignment of ", stringify!(_FSP_SERVICE))
    );
    fn test_field_Version() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).Version) as usize - ptr as usize
            },
            0usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(Version)
            )
        );
    }
    test_field_Version();
    fn test_field_UserContext() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).UserContext) as usize - ptr as usize
            },
            8usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(UserContext)
            )
        );
    }
    test_field_UserContext();
    fn test_field_OnStart() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OnStart) as usize - ptr as usize
            },
            16usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(OnStart)
            )
        );
    }
    test_field_OnStart();
    fn test_field_OnStop() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OnStop) as usize - ptr as usize
            },
            24usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(OnStop)
            )
        );
    }
    test_field_OnStop();
    fn test_field_OnControl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).OnControl) as usize - ptr as usize
            },
            32usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(OnControl)
            )
        );
    }
    test_field_OnControl();
    fn test_field_AcceptControl() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AcceptControl) as usize - ptr as usize
            },
            40usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(AcceptControl)
            )
        );
    }
    test_field_AcceptControl();
    fn test_field_ExitCode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ExitCode) as usize - ptr as usize
            },
            44usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ExitCode)
            )
        );
    }
    test_field_ExitCode();
    fn test_field_StatusHandle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).StatusHandle) as usize - ptr as usize
            },
            48usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(StatusHandle)
            )
        );
    }
    test_field_StatusHandle();
    fn test_field_ServiceStatus() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ServiceStatus) as usize - ptr as usize
            },
            56usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceStatus)
            )
        );
    }
    test_field_ServiceStatus();
    fn test_field_ServiceStatusGuard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ServiceStatusGuard) as usize - ptr as usize
            },
            88usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceStatusGuard)
            )
        );
    }
    test_field_ServiceStatusGuard();
    fn test_field_ServiceStopGuard() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ServiceStopGuard) as usize - ptr as usize
            },
            128usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceStopGuard)
            )
        );
    }
    test_field_ServiceStopGuard();
    fn test_field_AllowConsoleMode() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).AllowConsoleMode) as usize - ptr as usize
            },
            168usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(AllowConsoleMode)
            )
        );
    }
    test_field_AllowConsoleMode();
    fn test_field_ServiceName() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<_FSP_SERVICE>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).ServiceName) as usize - ptr as usize
            },
            170usize,
            concat!(
            "Offset of field: ",
            stringify!(_FSP_SERVICE),
            "::",
            stringify!(ServiceName)
            )
        );
    }
    test_field_ServiceName();
}
impl Default for _FSP_SERVICE {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Run a service."]
    #[doc = ""]
    #[doc = " This function wraps calls to FspServiceCreate, FspServiceLoop and FspServiceDelete to create,"]
    #[doc = " run and delete a service. It is intended to be used from a service's main/wmain function."]
    #[doc = ""]
    #[doc = " This function runs a service with console mode allowed."]
    #[doc = ""]
    #[doc = " @param ServiceName"]
    #[doc = "     The name of the service."]
    #[doc = " @param OnStart"]
    #[doc = "     Function to call when the service starts."]
    #[doc = " @param OnStop"]
    #[doc = "     Function to call when the service stops."]
    #[doc = " @param OnControl"]
    #[doc = "     Function to call when the service receives a service control code."]
    #[doc = " @return"]
    #[doc = "     Service process exit code."]
    pub fn FspServiceRunEx(
        ServiceName: PWSTR,
        OnStart: FSP_SERVICE_START,
        OnStop: FSP_SERVICE_STOP,
        OnControl: FSP_SERVICE_CONTROL,
        UserContext: PVOID,
    ) -> ULONG;
}
extern "C" {
    #[doc = " Create a service object."]
    #[doc = ""]
    #[doc = " @param ServiceName"]
    #[doc = "     The name of the service."]
    #[doc = " @param OnStart"]
    #[doc = "     Function to call when the service starts."]
    #[doc = " @param OnStop"]
    #[doc = "     Function to call when the service stops."]
    #[doc = " @param OnControl"]
    #[doc = "     Function to call when the service receives a service control code."]
    #[doc = " @param PService [out]"]
    #[doc = "     Pointer that will receive the service object created on successful return from this"]
    #[doc = "     call."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspServiceCreate(
        ServiceName: PWSTR,
        OnStart: FSP_SERVICE_START,
        OnStop: FSP_SERVICE_STOP,
        OnControl: FSP_SERVICE_CONTROL,
        PService: *mut *mut FSP_SERVICE,
    ) -> NTSTATUS;
}
extern "C" {
    #[doc = " Delete a service object."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    pub fn FspServiceDelete(Service: *mut FSP_SERVICE);
}
extern "C" {
    #[doc = " Allow a service to run in console mode."]
    #[doc = ""]
    #[doc = " A service that is run in console mode runs with a console attached and outside the control of"]
    #[doc = " the Service Control Manager. This is useful for debugging and testing a service during"]
    #[doc = " development."]
    #[doc = ""]
    #[doc = " User mode file systems that wish to use the WinFsp Launcher functionality must also use this"]
    #[doc = " call. The WinFsp Launcher is a Windows service that can be configured to launch and manage"]
    #[doc = " multiple instances of a user mode file system."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    pub fn FspServiceAllowConsoleMode(Service: *mut FSP_SERVICE);
}
extern "C" {
    #[doc = " Configure the control codes that a service accepts."]
    #[doc = ""]
    #[doc = " This API should be used prior to Start operations."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    #[doc = " @param Control"]
    #[doc = "     The control codes to accept. Note that the SERVICE_ACCEPT_PAUSE_CONTINUE code is silently"]
    #[doc = "     ignored."]
    pub fn FspServiceAcceptControl(Service: *mut FSP_SERVICE, Control: ULONG);
}
extern "C" {
    #[doc = " Request additional time from the Service Control Manager."]
    #[doc = ""]
    #[doc = " This API should be used during Start and Stop operations only."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    #[doc = " @param Time"]
    #[doc = "     Additional time (in milliseconds)."]
    pub fn FspServiceRequestTime(Service: *mut FSP_SERVICE, Time: ULONG);
}
extern "C" {
    #[doc = " Set the service process exit code."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    #[doc = " @param ExitCode"]
    #[doc = "     Service process exit code."]
    pub fn FspServiceSetExitCode(Service: *mut FSP_SERVICE, ExitCode: ULONG);
}
extern "C" {
    #[doc = " Get the service process exit code."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    #[doc = " @return"]
    #[doc = "     Service process exit code."]
    pub fn FspServiceGetExitCode(Service: *mut FSP_SERVICE) -> ULONG;
}
extern "C" {
    #[doc = " Run a service main loop."]
    #[doc = ""]
    #[doc = " This function starts and runs a service. It executes the Windows StartServiceCtrlDispatcher API"]
    #[doc = " to connect the service process to the Service Control Manager. If the Service Control Manager is"]
    #[doc = " not available (and console mode is allowed) it will enter console mode."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspServiceLoop(Service: *mut FSP_SERVICE) -> NTSTATUS;
}
extern "C" {
    #[doc = " Stops a running service."]
    #[doc = ""]
    #[doc = " Stopping a service usually happens when the Service Control Manager instructs the service to"]
    #[doc = " stop. In some situations (e.g. fatal errors) the service may wish to stop itself. It can do so"]
    #[doc = " in a clean manner by calling this function."]
    #[doc = ""]
    #[doc = " @param Service"]
    #[doc = "     The service object."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS or error code."]
    pub fn FspServiceStop(Service: *mut FSP_SERVICE);
}
extern "C" {
    #[doc = " Determine if the current process is running in user interactive mode."]
    #[doc = ""]
    #[doc = " @return"]
    #[doc = "     TRUE if the process is running in running user interactive mode."]
    pub fn FspServiceIsInteractive() -> BOOLEAN;
}
extern "C" {
    #[doc = " Check if the supplied token is from the service context."]
    #[doc = ""]
    #[doc = " @param Token"]
    #[doc = "     Token to check. Pass NULL to check the current process token."]
    #[doc = " @param PIsLocalSystem"]
    #[doc = "     Pointer to a boolean that will receive a TRUE value if the token belongs to LocalSystem"]
    #[doc = "     and FALSE otherwise. May be NULL."]
    #[doc = " @return"]
    #[doc = "     STATUS_SUCCESS if the token is from the service context. STATUS_ACCESS_DENIED if it is not."]
    #[doc = "     Other error codes are possible."]
    pub fn FspServiceContextCheck(Token: HANDLE, PIsLocalSystem: PBOOLEAN) -> NTSTATUS;
}
extern "C" {
    #[doc = " Log a service message."]
    #[doc = ""]
    #[doc = " This function can be used to log an arbitrary message to the Windows Event Log or to the current"]
    #[doc = " console if running in user interactive mode."]
    #[doc = ""]
    #[doc = " @param Type"]
    #[doc = "     One of EVENTLOG_INFORMATION_TYPE, EVENTLOG_WARNING_TYPE, EVENTLOG_ERROR_TYPE."]
    #[doc = " @param Format"]
    #[doc = "     Format specification. This function uses the Windows wsprintf API for formatting. Refer to"]
    #[doc = "     that API's documentation for details on the format specification."]
    pub fn FspServiceLog(Type: ULONG, Format: PWSTR, ...);
}
extern "C" {
    pub fn FspServiceLogV(Type: ULONG, Format: PWSTR, ap: va_list);
}
extern "C" {
    pub fn FspNtStatusFromWin32(Error: DWORD) -> NTSTATUS;
}
extern "C" {
    pub fn FspWin32FromNtStatus(Status: NTSTATUS) -> DWORD;
}
extern "C" {
    pub fn FspEventLog(Type: ULONG, Format: PWSTR, ...);
}
extern "C" {
    pub fn FspEventLogV(Type: ULONG, Format: PWSTR, ap: va_list);
}
extern "C" {
    pub fn FspDebugLogSetHandle(Handle: HANDLE);
}
extern "C" {
    pub fn FspDebugLog(Format: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn FspDebugLogSD(
        Format: *const ::std::os::raw::c_char,
        SecurityDescriptor: PSECURITY_DESCRIPTOR,
    );
}
extern "C" {
    pub fn FspDebugLogSid(format: *const ::std::os::raw::c_char, Sid: PSID);
}
extern "C" {
    pub fn FspDebugLogFT(Format: *const ::std::os::raw::c_char, FileTime: PFILETIME);
}
extern "C" {
    pub fn FspDebugLogRequest(Request: *mut FSP_FSCTL_TRANSACT_REQ);
}
extern "C" {
    pub fn FspDebugLogResponse(Response: *mut FSP_FSCTL_TRANSACT_RSP);
}
extern "C" {
    pub fn FspCallNamedPipeSecurely(
        PipeName: PWSTR,
        InBuffer: PVOID,
        InBufferSize: ULONG,
        OutBuffer: PVOID,
        OutBufferSize: ULONG,
        PBytesTransferred: PULONG,
        Timeout: ULONG,
        Sid: PSID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspCallNamedPipeSecurelyEx(
        PipeName: PWSTR,
        InBuffer: PVOID,
        InBufferSize: ULONG,
        OutBuffer: PVOID,
        OutBufferSize: ULONG,
        PBytesTransferred: PULONG,
        Timeout: ULONG,
        AllowImpersonation: BOOLEAN,
        Sid: PSID,
    ) -> NTSTATUS;
}
extern "C" {
    pub fn FspVersion(PVersion: PUINT32) -> NTSTATUS;
}
